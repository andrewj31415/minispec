<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Minispec Visual</title>
        <style>
            :root {
                --button-gray: rgb(192, 192, 192);
                font-size: 10pt;
                font-family: Consolas;
            }
            html {
                height: 100vh;
                width: 100vw;
                overflow: hidden;
            }
            body {
                background-color: white;
                height: 100%;
                margin: 0;
            }
            #root {
                height: 100%;
                width: 100%;
                display: flex;
                flex-direction: row;
                position: relative;
            }
            #source-div {
                position: relative;
                height: 100%;
                width: 35vw;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                font-family: Consolas, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono,
                    Courier New; /* see https://meta.stackexchange.com/questions/36176/whats-the-font-used-in-code-blocks */
            }
            #source-filenames-div {
                z-index: 2;
                width: 100%;
                background-color: rgb(220, 220, 220);
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                flex-shrink: 0;
            }
            .source-filename-div {
                padding: 10px;
                background-color: var(--button-gray);
                cursor: pointer;
            }
            #source-filetexts-div {
                position: relative;
                width: 100%;
                flex-grow: 1;
            }
            .source-file-div {
                z-index: 0;
                position: absolute;
                white-space: pre;
                overflow: auto;
                width: 100%;
                height: 100%;
                background-color: white;
            }
            #resize-div {
                height: 100%;
                width: 4px;
                background-color: black;
                cursor: e-resize;
            }
            #display-svg {
                object-fit: contain;
                flex: 2;
                cursor: default;
            }
            #control-button-div {
                width: 150px;
                height: 50px;
                position: absolute;
                bottom: 0;
                right: 0;
            }
            #button-fullscreen-background-div {
                z-index: 1;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 105px;
                background-color: var(--button-gray);
            }
            #button-fullscreen-image-embed {
                z-index: 2;
                position: absolute;
                width: 50px;
                height: 50px;
                top: 0px;
                left: 100px;
            }
            #button-fullscreen-click-div {
                z-index: 3;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 105px;
                background-color: transparent;
                cursor: pointer;
            }
            #button-resetzoom-image-embed {
                z-index: 2;
                position: absolute;
                width: 50px;
                height: 50px;
                top: 0px;
                left: 50px;
            }
            #button-resetzoom-background-div {
                z-index: 1;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 55px;
                background-color: var(--button-gray);
            }
            #button-resetzoom-click-div {
                z-index: 3;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 55px;
                background-color: transparent;
                cursor: pointer;
            }
            #button-help-image-embed {
                z-index: 2;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 5px;
            }
            #button-help-background-div {
                z-index: 1;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 5px;
                background-color: var(--button-gray);
            }
            #button-help-click-div {
                z-index: 3;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 5px;
                background-color: transparent;
                cursor: pointer;
            }
            #help-container-div {
                width: 100%;
                height: 100%;
                position: absolute;
                top: 0;
                left: 0;
                display: flex;
                flex-direction: row;
                overflow: hidden;
                align-items: center;
                justify-content: center;
                pointer-events: none;
            }
            #help-div {
                /* See https://codepen.io/imprakash/pen/GgNMXO */
                width: 80%;
                height: 80%;
                overflow: auto;
                background-color: white;
                border-width: 3px;
                border-color: black;
                border-style: solid;
                z-index: 5;
                pointer-events: all;
                display: none; /* avoids showing the help div briefly while the rest of the page loads */
            }
            #wire-inspect-div {
                position: absolute;
                font-size: 16pt;
                padding: 4px 4px;
                background-color: lightgray;
                border-width: 1px;
                border-color: gray;
                border-style: solid;
                z-index: 6;
                pointer-events: none;
            }
        </style>
    </head>
    <body>
        <div id="root">
            <div id="source-div">
                <div id="source-filenames-div"></div>
                <div id="source-filetexts-div"></div>
            </div>
            <div id="resize-div" onmousedown="event.preventDefault(); /* prevents highlighting of source when resizing */"></div>
            <svg id="display-svg" viewBox="0 0 100 100"></svg>
            <div id="wire-inspect-div"></div>
            <div id="control-button-div">
                <div id="button-fullscreen-background-div"></div>
                <div id="button-resetzoom-background-div"></div>
                <div id="button-help-background-div"></div>
                <!-- Source: https://thenounproject.com/icon/reset-zoom-54041/ -->
                <embed
                    id="button-resetzoom-image-embed"
                    src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNzUycHQiIGhlaWdodD0iNzUycHQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDc1MiA3NTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiA8ZGVmcz4KICA8Y2xpcFBhdGggaWQ9ImEiPgogICA8cGF0aCBkPSJtMTQyIDE2OGg0NzAuNzl2NDMxaC00NzAuNzl6Ii8+CiAgPC9jbGlwUGF0aD4KIDwvZGVmcz4KIDxnIGNsaXAtcGF0aD0idXJsKCNhKSI+CiAgPHBhdGggZD0ibTYwNCA1MjQuNzVjLTAuMzA4NTktMC4yODUxNi0wLjY0NDUzLTAuNDMzNTktMC45MjE4OC0wLjY3OTY5bC04NS40MzgtODMuOTY5LTIxLjU1NS0yMS4xNzZjMjIuMDI3LTQ4LjQ3NyAyMi4xNDEtMTA2LjMtNC43OTY5LTE1Ni44LTQ2LjAwNC04Ni4xNTItMTUzLjUyLTExOC44NS0yMzkuNjctNzIuODc5LTEuODIwMyAwLjk2NDg0LTMuNTM5MSAyLjA1ODYtNS4zMTY0IDMuMDk3Ny0yNy43ODEgMTYuMDc4LTQ5LjY5NSAzOC42MzctNjQuNzE5IDY0LjgwNS05Ljk4NDQtNS4xMjUtMTcuMjE1LTkuNTcwMy0xOC4yNTQtMTAuMjM0IDAuOTgwNDcgMC42MzY3MiAwLjMxMjUgMC4wMzEyNS0wLjkxNzk3LTAuODQzNzUtMC44ODY3Mi0wLjc0MjE5LTEuODk0NS0xLjMyMDMtMi45OTIyLTEuODA4Ni0wLjQxNDA2LTAuMjEwOTQtMC44NTkzNy0wLjM4NjcyLTEuMjE0OC0wLjUwNzgxLTAuOTQ5MjItMC4yOTY4OC0xLjkyNTgtMC40MTQwNi0yLjg3NS0wLjQ0MTQxLTAuMjM0MzgtMC4wMzEyNS0wLjQxNDA2LTAuMDE1NjI1LTAuNjgzNTktMC4wMTU2MjUtMC44MjgxMiAwLjAxNTYyNS0xLjY1NjIgMC4xMDE1Ni0yLjQ2MDkgMC4yODEyNS0wLjA4OTg0NCAwLjAzMTI1LTAuMTc1NzggMC4wMzEyNS0wLjI2NTYzIDAuMDU4NTk0LTMuODc4OSAwLjk2NDg0LTcuMTk5MiAzLjg1MTYtOC40NTcgOC0wLjQ4ODI4IDEuNTI3My0wLjU3ODEyIDMuMDgyLTAuNDQxNDEgNC41OTM4IDAgMC0wLjA0Njg3NSAwLjA0Njg3NS0wLjAxNTYyNSAwLjA1ODU5M3YwLjAzMTI1YzAuMDMxMjUgMS4zMzIgMC4xNzU3OCAyLjc1MzkgMC41MzEyNSA0LjI2NTZsMTUuMzk4IDY2LjIwNyA0LjgxMjUgMjAuNzg1IDQuMjgxMiAxOC4zNDQgMS4zNzUgNS44OTQ1YzIuODE2NCAxMi4yNDIgMTIuNjUyIDE1LjIzIDIxLjg0IDYuNjQwNmwyMC41MDQtMTkuMTU2IDUuODA4Ni01LjQ1MzEgMTMuMzU5LTEyLjQ4OCA0MS4wNy0zOC40MTggMi42NTIzLTIuNDc2NmMwLjMxMjUtMC4yOTY4OCAwLjUxOTUzLTAuNTkzNzUgMC43ODUxNi0wLjg4NjcybDEuNzIyNy0xLjY5MTQtMC4xMjEwOS0wLjAzMTI1YzEuMDcwMy0xLjIxNDggMS45ODgzLTIuNjA1NSAyLjQ4ODMtNC4yMzgzIDAuMTM2NzItMC40Mjk2OSAwLjE3OTY5LTAuODU5MzggMC4yNjU2My0xLjI3MzQgMC43OTY4Ny0zLjE3MTkgMC4xNzU3OC02LjE5MTQtMS44MDg2LTguNzM4My0xLjQ2NDgtMi4xNzk3LTMuNjEzMy0zLjkxMDItNi4zMTI1LTQuNzI2NiAwIDAtMTUuOTY5IDEuMTA5NC0zOC45MzQtMy40ODQ0IDUuMzA0Ny03LjczMDUgMTEuNDk2LTE0LjkwMiAxOC41NDctMjEuMzc5IDcuNDk2MS02Ljg1OTQgMTUuOTQxLTEyLjkzNCAyNS4zMDUtMTcuOTI2IDE3LjU3NC05LjM2MzMgMzYuMzg3LTE0LjA0NyA1NS4wMjctMTQuNTIgNDUuNDg0LTEuMTY4IDg5Ljk4OCAyMi43NTQgMTEyLjg0IDY1LjU1OSAyOC45MTggNTQuMjIzIDEzLjM2MyAxMjAuNDgtMzMuODY3IDE1Ni43My0xLjY0MDYgMS4yNDYxLTMuMjg5MSAyLjQ3NjYtNC45NzY2IDMuNjQ4NC0wLjY1MjM0IDAuNDQxNDEtMS4zMDQ3IDAuODg2NzItMS45NTMxIDEuMzIwMy0wLjQxNDA2IDAuMjk2ODgtMC44NTkzOCAwLjU2MjUtMS4zMDQ3IDAuODQzNzUtMi4yMjI3IDEuNDQxNC00LjUzNTIgMi43NTM5LTYuODc1IDQuMDc0Mi0zMy45MyAxOC43MTUtNzYuMTIxIDIxLjM2My0xMTMuNjYgMy4zNTE2LTQuODkwNi0yLjM1OTQtOS41NDMtNS4wMzkxLTEzLjk4NC03Ljk0MTQtMS4yNzM0LTAuODMyMDMtMi41NjY0LTEuNjg3NS0zLjgyMDMtMi41NzgxLTAuOTE3OTctMC4yOTY4OC0xLjg2NzItMC41MDc4MS0yLjg5MDYtMC41MDc4MS0xLjY3NTggMC4wMzEyNS0zLjIxNDggMC41MTk1My00LjUzMTIgMS4zMzJsLTEuNzA3IDEuMzUxNi0yNy4xNDEgMjEuMTU2LTMuMTA5NCAyLjQxNDFjLTEuMjczNCAxLjUzOTEtMi4wNDY5IDMuNDg0NC0yLjA0NjkgNS42NDg0IDAuMDMxMjUgMS44MjAzIDAuNTkzNzUgMy41MTE3IDEuNTM5MSA0LjkxOCAxLjMzMiAxLjA4MiAyLjY5NTMgMi4xNjQxIDQuMDYyNSAzLjIxNDggOS4zOTA2IDcuMTg3NSAxOS42MTMgMTMuNTM5IDMwLjY4IDE4Ljg0NCAzOS4xMzMgMTguNzg5IDgxLjc3IDIxLjgyIDEyMC44MiAxMS43MzQgMC4xMTcxOSAwIDAuMjM0MzggMC4wNTg1OTQgMC4zODY3MiAwLjA1ODU5NCAxLjY1NjItMC40NDUzMSAzLjMzNTktMC44ODY3MiA0Ljk4MDUtMS4zNTk0IDExLjM0OC0zLjMyMDMgMjIuNTItNy43OTY5IDMzLjM2My0xMy41NzQgNC4zNjcyLTIuMzM5OCA4LjU2MjUtNC44NzUgMTIuNjgtNy41MjM0IDAuNTYyNS0wLjM1NTQ3IDEuMTQ0NS0wLjcwNzAzIDEuNzA3LTEuMDgyIDEuMTk5Mi0wLjc4NTE2IDIuMzU1NS0xLjYxNzIgMy41MzkxLTIuNDE0MSAwLjQxNDA2LTAuMjkyOTcgMC44MDg1OS0wLjU4NTk0IDEuMjE4OC0wLjg3MTA5bDE4LjE1MiAxNy44NzkgODIuNzM0IDgxLjI1NGMwLjE4MzU5IDAuMTg3NSAwLjMzNTk0IDAuNTAzOTEgMC41MjM0NCAwLjcwNzAzIDE0LjE1NiAxNC4wOTggNDAuMTA5IDEwLjk3MyA1OC4wMTItNyAxNy45NjUtMTcuOTQ1IDIxLjA5NC00My45NDUgNy4wMzEyLTU4LjAxMnoiLz4KIDwvZz4KPC9zdmc+Cg=="
                />
                <!-- Source: https://thenounproject.com/icon/fullscreen-1337699/ -->
                <embed
                    id="button-fullscreen-image-embed"
                    src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNzUycHQiIGhlaWdodD0iNzUycHQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDc1MiA3NTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiA8Zz4KICA8cGF0aCBkPSJtMTc4LjY4IDE3OC42OHYzOTQuNjVoMzk0LjY1di0zOTQuNjV6bTM1NS4xOSAzNTUuMTloLTMxNS43MnYtMzE1LjcyaDMxNS43MnoiLz4KICA8cGF0aCBkPSJtMzM2LjU0IDQ3NC42NmgtMzEuMjkzbDQ1LjI0Ni00NS4yNDYtMjcuOTAyLTI3LjkwMi00NS4yNDYgNDUuMjQ2di0zMS4yOTdoLTM5LjQ2NXY5OC42NjRoOTguNjZ6Ii8+CiAgPHBhdGggZD0ibTQyOS40MiAzNTAuNDkgNDUuMjQ2LTQ1LjI0NnYzMS4yOTNoMzkuNDY1di05OC42NmgtOTguNjY0djM5LjQ2NWgzMS4yOTdsLTQ1LjI0NiA0NS4yNDZ6Ii8+CiA8L2c+Cjwvc3ZnPgo="
                />
                <!-- Source: https://thenounproject.com/icon/help-2647215/ -->
                <embed
                    id="button-help-image-embed"
                    src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNzUycHQiIGhlaWdodD0iNzUycHQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDc1MiA3NTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiA8ZGVmcz4KICA8Y2xpcFBhdGggaWQ9ImIiPgogICA8cGF0aCBkPSJtMjE5IDEzOS4yMWgzMTR2MzI4Ljc5aC0zMTR6Ii8+CiAgPC9jbGlwUGF0aD4KICA8Y2xpcFBhdGggaWQ9ImEiPgogICA8cGF0aCBkPSJtMzEyIDUxMGgxMDN2MTAyLjc5aC0xMDN6Ii8+CiAgPC9jbGlwUGF0aD4KIDwvZGVmcz4KIDxnPgogIDxnIGNsaXAtcGF0aD0idXJsKCNiKSI+CiAgIDxwYXRoIGQ9Im0zNjguNTcgMTM5LjIxYzMwLjUyLTAuNDQ5MjIgNjAuODA1IDUuMzY3MiA4OC45ODQgMTcuMDk4IDIzLjg2NyA5LjU2MjUgNDQuMTAyIDI2LjQxOCA1Ny44MjQgNDguMTYgMTYuNjg4IDI3LjAyMyAyMS40NjkgNTkuNzM4IDEzLjIxNSA5MC40MS01LjIxMDkgMjEuMTIxLTE3Ljk5NiAzOC4xMjUtMzMuMTUyIDUzLjMyNC0xMi42NTIgMTEuOTY5LTI2LjE4OCAyMi45NzMtNDAuNDg4IDMyLjkxNC0xMC4zNzEgNy41NzgxLTIwLjUwOCAxNS41MzUtMzAuNTk0IDIzLjY4LTYuODQzOCA1Ljg2MzMtMTIuMDc4IDEzLjM3OS0xNS4yMDMgMjEuODMyLTIuNTU4NiA2LjAzMTItNS4wODIgMTIuMDc4LTcuNTc4MSAxOC4xMzctNS42ODM2IDE0LjU4Ni0xNy4xNDUgMjEuMjE1LTMyLjE1NiAyMi4xNjQtOS4xOTE0IDEuMjE0OC0xOC41MzEtMC42MzI4MS0yNi41NjYtNS4yNTc4LTYuNTIzNC00LjA3ODEtMTEuODItOS44NDM4LTE1LjMzMi0xNi42OTEtMy41MDc4LTYuODQzOC01LjEwMTYtMTQuNTEyLTQuNjA1NS0yMi4xODggMC41MTU2My0xOS4wMiA4LjExNzItMzcuMTU2IDIxLjMwOS01MC44NjMgMTQuNjMzLTE2LjYyMSAzMi43MjMtMjkuMjE5IDQ5Ljg2Ny00Mi45MDZoMC4wMDM5MDZjMTMuMjk3LTkuNjUyMyAyNC43NjItMjEuNjAyIDMzLjg1OS0zNS4yODEgMTIuNDU3LTIwLjYwMiA4LjU3MDMtNTQuNDYxLTEyLjY0NS02OS40NzN2LTAuMDAzOTA2Yy03LjY2OC01LjM5NDUtMTYuNDYxLTguOTcyNy0yNS43MTUtMTAuNDY1LTE0LjA5OC0yLjYzNjctMjguNjI1LTEuODI0Mi00Mi4zNCAyLjM2NzItMTUuOTE0IDUuMDE5NS0yNi4wOTQgMTYuNTc0LTMzLjU3OCAzMC45NzMtNS40NDUzIDEwLjUxMi0xMC4zMjQgMjEuNDA2LTE2LjU3NCAzMS40NDUtMTAuNTEyIDE2Ljk1My0yOC4wODIgMjAuNjQ4LTQ1Ljc0NiAxNy40M3YtMC4wMDM5MDZjLTcuNzA3LTEuMjA3LTE0Ljg4My00LjY4MzYtMjAuNjAyLTkuOTkyMi03LjY3NTgtNy41MjM0LTExLjcwMy0xOC4wMTYtMTEuMDM1LTI4Ljc0NiAwLjI3NzM0LTE4LjMwMSA2LjAzNTItMzYuMTAyIDE2LjUyNy01MS4wOTggMTcuNjI1LTI1LjMyOCA0Mi42NTItNDQuNTg2IDcxLjY1Ni01NS4xMjUgMTkuMzc1LTcuNDYwOSAzOS45MDYtMTEuNDY5IDYwLjY2NC0xMS44NHoiLz4KICA8L2c+CiAgPGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj4KICAgPHBhdGggZD0ibTQxNC42IDU2MS42YzAgMjguMjczLTIyLjkxOCA1MS4xOTUtNTEuMTk1IDUxLjE5NS0yOC4yNzMgMC01MS4xOTEtMjIuOTIyLTUxLjE5MS01MS4xOTUgMC0yOC4yNzMgMjIuOTE4LTUxLjE5NSA1MS4xOTEtNTEuMTk1IDI4LjI3NyAwIDUxLjE5NSAyMi45MjIgNTEuMTk1IDUxLjE5NSIvPgogIDwvZz4KIDwvZz4KPC9zdmc+Cg=="
                />
                <div id="button-fullscreen-click-div" onclick="document.documentElement.requestFullscreen()"></div>
                <div id="button-resetzoom-click-div"></div>
                <div
                    id="button-help-click-div"
                    onmousedown="event.preventDefault(); /* prevents highlighting of div when clicking on icon */"
                ></div>
            </div>
            <div id="help-container-div">
                <div id="help-div">
                    Hello! Welcome to Minispec Visual!
                    <p>
                        The left pane shows the source code. The right pane displays a diagram of the synthesized circuit. The
                        circuit is not currently displayed at the logic gate level, though this might be added in the future.
                    </p>
                    <p>
                        You can drag to move and either scroll or pinch to zoom. Click
                        <!-- Source: https://thenounproject.com/icon/reset-zoom-54041/ -->
                        <svg style="display: inline; vertical-align: middle; width: 14pt; height: 14pt" viewBox="100 100 552 552">
                            <g xmlns="http://www.w3.org/2000/svg">
                                <path
                                    xmlns="http://www.w3.org/2000/svg"
                                    d="m604 524.75c-0.30859-0.28516-0.64453-0.43359-0.92188-0.67969l-85.438-83.969-21.555-21.176c22.027-48.477 22.141-106.3-4.7969-156.8-46.004-86.152-153.52-118.85-239.67-72.879-1.8203 0.96484-3.5391 2.0586-5.3164 3.0977-27.781 16.078-49.695 38.637-64.719 64.805-9.9844-5.125-17.215-9.5703-18.254-10.234 0.98047 0.63672 0.3125 0.03125-0.91797-0.84375-0.88672-0.74219-1.8945-1.3203-2.9922-1.8086-0.41406-0.21094-0.85937-0.38672-1.2148-0.50781-0.94922-0.29688-1.9258-0.41406-2.875-0.44141-0.23438-0.03125-0.41406-0.015625-0.68359-0.015625-0.82812 0.015625-1.6562 0.10156-2.4609 0.28125-0.089844 0.03125-0.17578 0.03125-0.26563 0.058594-3.8789 0.96484-7.1992 3.8516-8.457 8-0.48828 1.5273-0.57812 3.082-0.44141 4.5938 0 0-0.046875 0.046875-0.015625 0.058593v0.03125c0.03125 1.332 0.17578 2.7539 0.53125 4.2656l15.398 66.207 4.8125 20.785 4.2812 18.344 1.375 5.8945c2.8164 12.242 12.652 15.23 21.84 6.6406l20.504-19.156 5.8086-5.4531 13.359-12.488 41.07-38.418 2.6523-2.4766c0.3125-0.29688 0.51953-0.59375 0.78516-0.88672l1.7227-1.6914-0.12109-0.03125c1.0703-1.2148 1.9883-2.6055 2.4883-4.2383 0.13672-0.42969 0.17969-0.85938 0.26563-1.2734 0.79687-3.1719 0.17578-6.1914-1.8086-8.7383-1.4648-2.1797-3.6133-3.9102-6.3125-4.7266 0 0-15.969 1.1094-38.934-3.4844 5.3047-7.7305 11.496-14.902 18.547-21.379 7.4961-6.8594 15.941-12.934 25.305-17.926 17.574-9.3633 36.387-14.047 55.027-14.52 45.484-1.168 89.988 22.754 112.84 65.559 28.918 54.223 13.363 120.48-33.867 156.73-1.6406 1.2461-3.2891 2.4766-4.9766 3.6484-0.65234 0.44141-1.3047 0.88672-1.9531 1.3203-0.41406 0.29688-0.85938 0.5625-1.3047 0.84375-2.2227 1.4414-4.5352 2.7539-6.875 4.0742-33.93 18.715-76.121 21.363-113.66 3.3516-4.8906-2.3594-9.543-5.0391-13.984-7.9414-1.2734-0.83203-2.5664-1.6875-3.8203-2.5781-0.91797-0.29688-1.8672-0.50781-2.8906-0.50781-1.6758 0.03125-3.2148 0.51953-4.5312 1.332l-1.707 1.3516-27.141 21.156-3.1094 2.4141c-1.2734 1.5391-2.0469 3.4844-2.0469 5.6484 0.03125 1.8203 0.59375 3.5117 1.5391 4.918 1.332 1.082 2.6953 2.1641 4.0625 3.2148 9.3906 7.1875 19.613 13.539 30.68 18.844 39.133 18.789 81.77 21.82 120.82 11.734 0.11719 0 0.23438 0.058594 0.38672 0.058594 1.6562-0.44531 3.3359-0.88672 4.9805-1.3594 11.348-3.3203 22.52-7.7969 33.363-13.574 4.3672-2.3398 8.5625-4.875 12.68-7.5234 0.5625-0.35547 1.1445-0.70703 1.707-1.082 1.1992-0.78516 2.3555-1.6172 3.5391-2.4141 0.41406-0.29297 0.80859-0.58594 1.2188-0.87109l18.152 17.879 82.734 81.254c0.18359 0.1875 0.33594 0.50391 0.52344 0.70703 14.156 14.098 40.109 10.973 58.012-7 17.965-17.945 21.094-43.945 7.0312-58.012z"
                                />
                            </g>
                        </svg>
                        to reset the zoom. Click
                        <!-- Source: https://thenounproject.com/icon/fullscreen-1337699/ -->
                        <svg style="display: inline; vertical-align: middle; width: 14pt; height: 14pt" viewBox="100 100 552 552">
                            <g xmlns="http://www.w3.org/2000/svg">
                                <path d="m178.68 178.68v394.65h394.65v-394.65zm355.19 355.19h-315.72v-315.72h315.72z" />
                                <path
                                    d="m336.54 474.66h-31.293l45.246-45.246-27.902-27.902-45.246 45.246v-31.297h-39.465v98.664h98.66z"
                                />
                                <path
                                    d="m429.42 350.49 45.246-45.246v31.293h39.465v-98.66h-98.664v39.465h31.297l-45.246 45.246z"
                                />
                            </g>
                        </svg>
                        to enter fullscreen; press escape to exit fullscreen.
                    </p>
                    <p>
                        If you hover over a component, its source code will be highlighted; if you double click
                        on a component, you will jump to the corresponding source code. If a component corresponds
                        to multiple locations in the source code (for instance, a function which is defined in
                        one location and called from another), double clicking repeatedly on that component will
                        cycle through the corresponding locations in the source code.
                        If you hover over a source token in a <span style="border-radius: 5px; border-width: 1.5px; border-style: solid; border-color:black;">black rectangle</span>, any corresponding components will be highlighted.
                        Clicking on that token will jump to and cycle through the corresponding components.
                    </p>
                    <p>
                        Currently, all internals of all components are displayed if available; hiding/showing internals
                        of components will be implemented in the future.
                    </p>
                </div>
            </div>
        </div>
        <script defer>
            /* assertions and runtime type checking */
            /* condition: boolean, message: string */
            assert = (condition, message = "Assertion Error.") => {
                if (!isBoolean(condition)) {
                    throw new Error(`assert statements may only take boolean conditions. Recieved: ${condition}`);
                }
                if (!isString(message)) {
                    throw new Error(`assert statements must have a string as a message. Recieved: ${message}`);
                }
                if (!condition) {
                    throw new Error(message);
                }
            };
            /* n: any
            Takes in any type and returns true if n is a number. */
            isNumber = (n) => {
                return typeof n === "number";
            };
            isString = (n) => {
                return typeof n === "string";
            };
            isFunction = (n) => {
                return typeof n === "function";
            };
            isBoolean = (n) => {
                return typeof n === "boolean";
            };
            isArray = (arr) => {
                return arr instanceof Array;
            };
            /* property: (any) => bool
            returns a function */
            isArrayWith = (property) => {
                /* arr: any
                Takes in any type and returns true if arr is an array such that every element has the given property. */
                return (arr) => {
                    if (!isArray(arr)) {
                        return false;
                    }
                    return arr.reduce((prev, cur) => prev && property(cur), true);
                };
            };
            /* Takes any number of function arguments. Returns a function that checks if an array is a tuple
            with the correct properties. */
            function isTupleWith() {
                for (let func of arguments) {
                    assert(isFunction(func), "isTupleWith can only be called on functions");
                }
                return (arr) => {
                    if (!isArray(arr)) {
                        return false;
                    }
                    return arr.reduce((prev, cur, index) => prev && arguments[index](cur), true);
                };
            }

            /* Globals */
            sourceDisplay = document.getElementById("source-div"); //The div with the source code
            sourceFilenameDisplay = document.getElementById("source-filenames-div"); //The div with the clickable filenames
            sourceFiletextDisplay = document.getElementById("source-filetexts-div"); //The div with the text of the files
            resizeDiv = document.getElementById("resize-div"); //The bar for resizing the display
            svgDisplay = document.getElementById("display-svg"); //The svg with the diagram
            helpDiv = document.getElementById("help-div"); //The div with help information
            helpClickDiv = document.getElementById("button-help-click-div"); //The button to click to show help information
            wireInspectDiv = document.getElementById("wire-inspect-div"); //This div will appear when hovering over a wire.

            /* Manage the wire inspect div */
            wireInspectDiv.style.visibility = "hidden";
            svgDisplay.addEventListener("mousemove", (event) => {
                wireInspectDiv.style.right = (window.innerWidth - event.clientX + 5) + "px";
                wireInspectDiv.style.bottom = (window.innerHeight - event.clientY + 5) + "px";
            });

            /* Handle showing the help information */
            helpDiv.style.visibility = "hidden";
            helpDiv.style.display = "block";
            helpDivOpening = false;
            helpDivOpen = false;
            window.addEventListener("click", () => {
                //See https://stackoverflow.com/questions/14188654/detect-click-outside-element-vanilla-javascript
                let isClickInside = helpDiv.contains(event.target);
                if (!isClickInside && !helpDivOpening) {
                    helpDiv.style.visibility = "hidden";
                    helpDivOpen = false;
                } else {
                    helpDivOpening = false;
                    helpDivOpen = true;
                    helpDiv.style.visibility = "";
                }
            });
            helpClickDiv.addEventListener("click", () => {
                if (!helpDivOpen) {
                    helpDivOpening = true;
                }
            });

            getSVGViewBox = () =>
                svgDisplay
                    .getAttribute("viewBox")
                    .split(" ")
                    .map((item) => Number(item)); //returns the viewbox of svgDisplay as an array of four numbers.
            /* Given a mouse event from an event listener, returns {x: number, y: number}
                                        where x and y are the svg coordinates of the click on svgDisplay.
                                        See https://stackoverflow.com/questions/29261304/how-to-get-the-click-coordinates-relative-to-svg-element-holding-the-onclick-lis
                                    */
            getSVGCoordinates = (event) => {
                let pt = svgDisplay.createSVGPoint();
                pt.x = event.clientX;
                pt.y = event.clientY;
                let cursorpt = pt.matrixTransform(svgDisplay.getScreenCTM().inverse());
                return cursorpt;
            };

            /* Allow the user to zoom in/out on the svg by scrolling. */
            svgDisplay.addEventListener("wheel", (e) => {
                e.preventDefault();
                let coords = getSVGCoordinates(e);
                let rescaleFactor = 2 ** (e.deltaY / 100);
                let currentSVGViewBox = getSVGViewBox();
                currentSVGViewBox = [
                    currentSVGViewBox[0] * rescaleFactor + coords.x * (1 - rescaleFactor),
                    currentSVGViewBox[1] * rescaleFactor + coords.y * (1 - rescaleFactor),
                    currentSVGViewBox[2] * rescaleFactor,
                    currentSVGViewBox[3] * rescaleFactor,
                ];
                svgDisplay.setAttribute("viewBox", currentSVGViewBox.join(" "));
            });

            /* Allow the user to click to zoom and drag to move
                                        See https://www.petercollingridge.co.uk/tutorials/svg/interactive/dragging/
                                    */
            isSVGDragging = false;
            startSVGDragging = (event) => {
                isSVGDragging = true;
                let coords = getSVGCoordinates(event);
                svgDraggingX = coords.x;
                svgDraggingY = coords.y;
            };
            stopSVGDragging = () => {
                isSVGDragging = false;
            };
            svgDisplay.addEventListener("mousedown", startSVGDragging);
            window.addEventListener("mouseup", stopSVGDragging);
            window.addEventListener("mousemove", (event) => {
                if (isSVGDragging) {
                    event.preventDefault(); //prevent dragging the svg from highlighting the source text
                    let newCoords = getSVGCoordinates(event);
                    let currentSVGViewBox = getSVGViewBox();
                    currentSVGViewBox = [
                        currentSVGViewBox[0] + svgDraggingX - newCoords.x,
                        currentSVGViewBox[1] + svgDraggingY - newCoords.y,
                        currentSVGViewBox[2],
                        currentSVGViewBox[3],
                    ];
                    svgDisplay.setAttribute("viewBox", currentSVGViewBox.join(" "));
                }
            });
            mobileRecalculateSvgDragging = (touches) => {
                /* computes the point that the SVG is being dragged from as the centroid of the fingers */
                let coordsArray = [...touches].map((touch) => getSVGCoordinates(touch));
                svgDraggingX = coordsArray.map((coords) => coords.x).reduce((prev, cur) => prev + cur) / coordsArray.length;
                svgDraggingY = coordsArray.map((coords) => coords.y).reduce((prev, cur) => prev + cur) / coordsArray.length;
                if (touches.length == 2) {
                    svgDraggingScale = Math.sqrt(
                        (coordsArray[0].x - coordsArray[1].x) ** 2 + (coordsArray[0].y - coordsArray[1].y) ** 2
                    );
                }
            };
            svgDisplay.addEventListener("touchstart", (event) => {
                isSVGDragging = true;
                //let coords = getSVGCoordinates(event.touches[0]);
                mobileRecalculateSvgDragging(event.touches);
            });
            svgDisplay.addEventListener("touchend", (event) => {
                if (event.touches.length === 0) {
                    //stop the dragging if no fingers are left
                    isSVGDragging = false;
                } else {
                    mobileRecalculateSvgDragging(event.touches);
                }
            });
            window.addEventListener(
                "touchmove",
                (event) => {
                    if (isSVGDragging && event.touches.length === 1 /*only one finger should drag svg */) {
                        event.preventDefault(); //prevent the touch from dragging the entire window
                        let newCoords = getSVGCoordinates(event.touches[0]);
                        let currentSVGViewBox = getSVGViewBox();
                        currentSVGViewBox = [
                            currentSVGViewBox[0] + svgDraggingX - newCoords.x,
                            currentSVGViewBox[1] + svgDraggingY - newCoords.y,
                            currentSVGViewBox[2],
                            currentSVGViewBox[3],
                        ];
                        svgDisplay.setAttribute("viewBox", currentSVGViewBox.join(" "));
                    } else if (isSVGDragging && event.touches.length === 2) {
                        event.preventDefault(); //prevent the touch from resizing the entire window
                        let newCoords1 = getSVGCoordinates(event.touches[0]);
                        let newCoords2 = getSVGCoordinates(event.touches[1]);
                        let currentSVGViewBox = getSVGViewBox();
                        currentSVGViewBox = [
                            currentSVGViewBox[0] + svgDraggingX - (newCoords1.x + newCoords2.x) / 2,
                            currentSVGViewBox[1] + svgDraggingY - (newCoords1.y + newCoords2.y) / 2,
                            currentSVGViewBox[2],
                            currentSVGViewBox[3],
                        ];
                        let rescaleFactor =
                            svgDraggingScale / Math.sqrt((newCoords1.x - newCoords2.x) ** 2 + (newCoords1.y - newCoords2.y) ** 2);
                        currentSVGViewBox = [
                            currentSVGViewBox[0] * rescaleFactor + svgDraggingX * (1 - rescaleFactor),
                            currentSVGViewBox[1] * rescaleFactor + svgDraggingY * (1 - rescaleFactor),
                            currentSVGViewBox[2] * rescaleFactor,
                            currentSVGViewBox[3] * rescaleFactor,
                        ];
                        svgDisplay.setAttribute("viewBox", currentSVGViewBox.join(" "));
                    }
                },
                { passive: false } //necessary to allow svg dragging to prevent default
            );

            /* Allow the user to resize the text display/svg display.
                                        See https://medium.com/the-z/making-a-resizable-div-in-js-is-not-easy-as-you-think-bda19a1bc53d */
            isResizing = false;
            startResize = (event) => {
                isResizing = true;
            };
            stopResize = () => {
                isResizing = false;
            };
            resizeDiv.addEventListener("mousedown", startResize);
            window.addEventListener("mouseup", stopResize);
            window.addEventListener("mousemove", (event) => {
                if (isResizing) {
                    sourceDisplay.style.width = event.pageX + "px";
                }
            });

            fontShrinkFactor = 0.75; //after we fit the text vertically, we shrink by this factor up to a few times to try to make the text fit horizontally.
            textNodesToFit = []; //Array<[textBoxNode, element]>
            /* Takes in a line of text and an object with x, y, width, and height attributes.
                                    Fits the text to the box, adds it to the DOM, and returns a reference to the resulting
                                    DOM object.
                                    Shrinks the font size to fit inside the box.
                                    details = {dominantBaseline, textAnchor} defaults to centering the text on both axes. */
            fitText = (text, element, details = {}) => {
                assert([undefined, "left", "center", "right"].includes(details.textAnchor), details.textAnchor);
                assert([undefined, "top", "center", "bottom"].includes(details.dominantBaseline), details.dominantBaseline);
                let textBox = document.createElementNS("http://www.w3.org/2000/svg", "text");
                textBox.textContent = text;
                switch (details.textAnchor ?? "center") {
                    case "center":
                        textBox.setAttribute("x", element.x + element.width / 2);
                        textBox.setAttribute("text-anchor", "middle");
                        break;
                    case "left":
                        textBox.setAttribute("x", element.x);
                        textBox.setAttribute("text-anchor", "start");
                        break;
                    case "right":
                        textBox.setAttribute("x", element.x + element.width);
                        textBox.setAttribute("text-anchor", "end");
                }
                switch (details.dominantBaseline ?? "centered") {
                    case "centered":
                        textBox.setAttribute("y", element.y + element.height / 2);
                        textBox.setAttribute("dominant-baseline", "central");
                        break;
                    case "top":
                        textBox.setAttribute("y", element.y);
                        textBox.setAttribute("dominant-baseline", "text-before-edge");
                        break;
                    case "bottom":
                        textBox.setAttribute("y", element.y + element.height);
                        textBox.setAttribute("dominant-baseline", "text-after-edge");
                }
                //fix the font size to fit vertically
                textBox.setAttribute("font-size", String(element.height) + "px");
                textBox.style.userSelect = "none";
                svgDisplay.appendChild(textBox);

                //short-circuit if the text has length 0
                if (text !== "") {
                    textNodesToFit.push([textBox, element]);
                }
                return textBox;
            };

            fitTextSteps = 0;
            textNodesUpdated = new Set(); /* The text nodes that have been updated, hence might need to be truncated */
            /* Shrinks the text in the [text, element] pairs of textNodesToFit to fit inside element.
            This is a separate function to improve performance--shrinking all text boxes together is faster. */
            fitAllText = () => {
                fitTextSteps += 1;
                let textNodesToUpdate = [];
                for (pair of textNodesToFit) {
                    let textBox = pair[0];
                    let element = pair[1];
                    if (textBox.getBBox().width > element.width) {
                        textNodesToUpdate.push(pair);
                    }
                }
                for (pair of textNodesToUpdate) {
                    let textBox = pair[0];
                    let element = pair[1];
                    let currentSize = Number(textBox.getAttribute("font-size").slice(0, -2));
                    currentSize = currentSize * fontShrinkFactor;
                    textBox.setAttribute("font-size", String(currentSize) + "px");
                    textNodesUpdated.add(pair);
                }
                textNodesToFit = textNodesToUpdate;
                if (fitTextSteps < 8) {
                    // shrink the text more
                    fitAllText();
                } else {
                    // cut off altered text with ellipses if necessary
                    for (pair of textNodesUpdated) {
                        let textBox = pair[0];
                        let element = pair[1];
                        if (textBox.getBBox().width > element.width) {
                            textBox.textContent += "...";
                            while (textBox.getBBox().width > element.width && textBox.textContent.length > 5) {
                                //remove the last letter before the ellipses
                                textBox.textContent = textBox.textContent.slice(0, -4) + "...";
                            }
                        }
                    }

                    //clear the list of text nodes to fit, since we have fit all of the text nodes on the list
                    textNodesToFit = [];
                    fitTextSteps = 0;
                    textNodesUpdated = new Set();
                }
            };

            /* Sources will be stored using sources: Map<filename: string, { tokens: Array<string> }> */
            sources = new Map();
            /* Python data goes here */

            /* Put the sources into the document */
            sourceDivs = new Map(); //each of these maps filenames to DOM elements.
            sourceTitleDivs = new Map();
            /* Both of the below have type Map<filename: string, { tokens: Array<HTMLSpanElement> }> 
            The span elements of each array also have an additional attribute, .components: Array<[{},{}]>
            which contains the objects with the data of the associated components and the parent positions. */
            sourceTokenAndWhitespaceSpanArrays = new Map(); //these map filenames to an array of DOM elements.
            sourceTokenSpanArrays = new Map(); //the ith span in this array represents the ith ANTLR4 token.

            /* Given a filename, pulls out the given source. */
            pullGivenSource = (filename) => {
                sourceDivs.forEach((sourceDiv, otherFilename) => {
                    sourceDiv.style.zIndex = 0;
                });
                sourceTitleDivs.forEach((sourceTitle, otherFilename) => {
                    sourceTitle.style.backgroundColor = "var(--button-gray)";
                });
                sourceDivs.get(filename).style.zIndex = 1;
                sourceTitleDivs.get(filename).style.backgroundColor = "white";
            };

            /* given token:str, returns true if token represents a comment or whitespace. */
            isWhitespaceOrComment = (token) => {
                return (
                    [" ", "\f", "\n", "\r", "\t"].includes(token[0]) ||
                    (token[0] === "/" && (token[1] === "/" || token[1] === "*"))
                );
            };

            // token color setting
            minispecKeywords = new Set([
                "begin",
                "bsvimport",
                "case",
                "default",
                "else",
                "end",
                "endcase",
                "endfunction",
                "endmethod",
                "endmodule",
                "endrule",
                "enum",
                "for",
                "function",
                "if",
                "import",
                "input",
                "let",
                "method",
                "module",
                "return",
                "rule",
                "struct",
                "type",
                "typedef",
            ]);
            /* Given a token:string, returns the color that the token should have. Based on the pygments/minispec.py file. */
            getTokenColor = (token) => {
                if (isWhitespaceOrComment(token)) {
                    return "green";
                }
                if (minispecKeywords.has(token)) {
                    return "blue";
                }
                if ("0123456789".includes(token[0]) || token === "False" || token == "True") {
                    return "red";
                }
                return "black";
            };

            // put the source tokens into the html, along with the filename headers
            for (let [sourceFileName, source] of sources) {
                let newSource = document.createElement("div");
                newSource.classList.add("source-file-div");
                let sourceTokens = [];
                for (let index = 0; index < source.tokens.length; index++) {
                    let token = source.tokens[index];
                    let tokenSpan = document.createElement("span");
                    tokenSpan.textContent = token;
                    tokenSpan.style.color = getTokenColor(token);
                    tokenSpan.components = [];  // The arrays of component objects that have source including this token.
                    tokenSpan.edges = [];
                    tokenSpan.linkComponent = (component, parentPos) => {
                        tokenSpan.components.push([component, parentPos]);
                        // tokenSpan.style.backgroundColor = "yellow";
                        tokenSpan.style.border = "1.5px solid black";
                        tokenSpan.style.borderRadius = "5px";
                        tokenSpan.style.cursor = "pointer";
                    };
                    tokenSpan.linkEdge = (edge, parentPos) => {
                        tokenSpan.edges.push([edge, parentPos]);
                        // tokenSpan.style.backgroundColor = "yellow";
                        tokenSpan.style.border = "1.5px solid black";
                        tokenSpan.style.borderRadius = "5px";
                        tokenSpan.style.cursor = "pointer";
                    };
                    // set up token to jump to source on click
                    tokenSpan.addEventListener("click", () => {
                        updateComponentJump(tokenSpan);
                    });
                    tokenSpan.addEventListener("mouseenter", () => {
                        if (tokenSpan.components.length != 0 || tokenSpan.edges.length != 0) {
                            // there are tokens corresponding to this component
                            highlightAssociatedComponents(tokenSpan);
                            clearHighlightedTokens();
                            highlightAdditionalToken(sourceFileName, index);
                        }
                    })
                    tokenSpan.addEventListener("mouseleave", () => {
                        clearHighlightedComponents();
                        clearHighlightedTokens();
                    })
                    sourceTokens.push(tokenSpan);
                }
                for (let tokenSpan of sourceTokens) {
                    newSource.appendChild(tokenSpan);
                }
                sourceFiletextDisplay.appendChild(newSource);
                sourceDivs.set(sourceFileName, newSource);
                sourceTokenAndWhitespaceSpanArrays.set(sourceFileName, sourceTokens);

                sourceTokenSpanArrays.set(
                    sourceFileName,
                    sourceTokens.filter((token) => {
                        return !isWhitespaceOrComment(token.textContent);
                    })
                );

                let newSourceTitle = document.createElement("div");
                newSourceTitle.classList.add("source-filename-div");
                newSourceTitle.textContent = sourceFileName;
                newSourceTitle.addEventListener("mousedown", (event) => {});
                newSourceTitle.addEventListener("click", (event) => {
                    pullGivenSource(sourceFileName);
                });
                sourceFilenameDisplay.prepend(newSourceTitle);
                sourceTitleDivs.set(sourceFileName, newSourceTitle);
            }
            pullGivenSource([...sources.keys()][sources.size-1]); //Pull out the first source file to start

            /* Start of code for highlighting tokens and components */

            /* Highlights the given token. Does not affect any other highlighted tokens. */
            highlightAdditionalToken = (filenameOfOrigin, tokenIndex) => {
                let tokenSpan = sourceTokenAndWhitespaceSpanArrays.get(filenameOfOrigin)[tokenIndex];
                tokenSpan.style.backgroundColor = "yellow";
                currentHighlightedTokens.add(tokenSpan);
            }
            /* Dehighlights all highlighted tokens */
            clearHighlightedTokens = () => {
                for (let token of currentHighlightedTokens) {
                    token.style.backgroundColor = "white";
                }
                currentHighlightedTokens = new Set();
            }

            /* Highlights the given source token. Dehighlights all other source tokens. */
            let currentHighlightedTokens = new Set();
            /* Highlights the given tokens. */
            highlightAssociatedTokens = (component, tokensToLink) => {
                for (filenameAndToken of tokensToLink) {
                    let filenameOfOrigin = filenameAndToken[0];
                    let tokenIndex = filenameAndToken[1];
                    highlightAdditionalToken(filenameOfOrigin, tokenIndex);
                }
            }

            /* Pulls up the given source and scrolls to the location. Places the location vertically centered
            and horizontally as far right as possible (but still on screen) with a few characters of leeway. */
            goToLocation = (filename, location) => {
                assert(isString(filename));
                assert(isNumber(location));
                pullGivenSource(filename);
                highlighterSpan = sourceTokenAndWhitespaceSpanArrays.get(filename)[location];
                highlighterSpanWidth = highlighterSpan.offsetWidth; //offsetWidth is for inline elements
                sourceDivHeight = sourceDivs.get(filename).clientHeight; //clientHeight excludes scrollbar
                sourceDivWidth = sourceDivs.get(filename).clientWidth;
                sourceDivs.get(filename).scrollTop = highlighterSpan.offsetTop - sourceDivHeight / 2;
                let horizontalPixelsOfLeeway = 14;
                sourceDivs.get(filename).scrollLeft = highlighterSpan.offsetLeft - sourceDivWidth + highlighterSpanWidth + horizontalPixelsOfLeeway;
            };
            /* Called by a component or edge on click. Cycles through the corresponding source tokens. */
            currentComponentInFocus = undefined;
            currentComponentSourceIndex = 0;
            jumpThroughSource = (component, tokensSourcedFrom) => {
                // tokensSourcedFrom should not change between consecutive calls to jumpThroughSource with the same component.
                assert(tokensSourcedFrom != undefined);
                assert(tokensSourcedFrom.length > 0);
                let tokensToLink = tokensSourcedFrom;
                if (currentComponentInFocus && currentComponentInFocus == component) {
                    currentComponentSourceIndex = (currentComponentSourceIndex + 1) % tokensToLink.length;
                } else {
                    currentComponentSourceIndex = 0;
                }
                currentComponentInFocus = component;
                let filenameOfOrigin = tokensToLink[currentComponentSourceIndex][0];
                let tokenIndex = tokensToLink[currentComponentSourceIndex][1];
                goToLocation(filenameOfOrigin, tokenIndex);
            }

            /* Called by a token on click. Cycles through the token's corresponding components.
            Returns false if there are no associated components and true otherwise. */
            currentTokenToJumpTo = undefined;
            currentIndexTokenToJumpTo = 0;
            updateComponentJump = (tokenSpan) => {
                if (tokenSpan.components.length == 0) {
                    // no components corresponding to this token, look through the edges
                    if (tokenSpan.edges.length == 0) {
                        return;
                    }
                    if (currentTokenToJumpTo && currentTokenToJumpTo == tokenSpan) {
                        currentIndexTokenToJumpTo = (currentIndexTokenToJumpTo + 1) % currentTokenToJumpTo.edges.length;
                    } else {
                        currentIndexTokenToJumpTo = 0;
                    }
                    currentTokenToJumpTo = tokenSpan;
                    let edge = tokenSpan.edges[currentIndexTokenToJumpTo][0];
                    let parentPos = tokenSpan.edges[currentIndexTokenToJumpTo][1];
                    jumpToEdge(edge, parentPos);
                    return;
                }
                if (currentTokenToJumpTo && currentTokenToJumpTo == tokenSpan) {
                    currentIndexTokenToJumpTo = (currentIndexTokenToJumpTo + 1) % currentTokenToJumpTo.components.length;
                } else {
                    currentIndexTokenToJumpTo = 0;
                }
                currentTokenToJumpTo = tokenSpan;
                let component = tokenSpan.components[currentIndexTokenToJumpTo][0];
                let parentPos = tokenSpan.components[currentIndexTokenToJumpTo][1];
                jumpToComponent(component, parentPos);
            };

            let currentHighlightedComponents = new Set();  // Stores the components currently being highlighted.
            let currentHighlightedEdges = new Set();  // Stores the edges currently being highlighted.
            /* Highlights the given component. Called by a component on mouse enter. */
            highlightComponent = (component) => {
                component.overRect.setAttribute("fill", "yellow");
                for (let portRect of component.portRects) {
                    portRect.setAttribute("fill", "yellow");
                }
                currentHighlightedComponents.add(component);
            }
            dehighlightComponent = (component) => {
                component.overRect.setAttribute("fill", "white");
                for (let portRect of component.portRects) {
                    portRect.setAttribute("fill", "white");
                }
            }
            clearHighlightedComponents = () => {
                for (let component of currentHighlightedComponents) {
                    dehighlightComponent(component);
                }
                for (let edge of currentHighlightedEdges) {
                    edge.dehighlightEdge();
                }
                currentHighlightedComponents = new Set();
                currentHighlightedEdges = new Set();
            }
            /* Called by a token on mouse enter. Highlights the corresponding components. */
            highlightAssociatedComponents = (tokenSpan) => {
                for (let componentAndParentPos of tokenSpan.components) {
                    let component = componentAndParentPos[0];
                    highlightComponent(component);
                }
                for (let edgeAndParentPos of tokenSpan.edges) {
                    let edge = edgeAndParentPos[0];
                    currentHighlightedEdges.add(edge);
                    edge.highlightEdge();
                }
            }

            /* End of code for highlighting tokens and components */

            elementsToPlace = {};
            /* Python data goes here */

            console.log(elementsToPlace);

            topLevel = elementsToPlace.children[0];

            /* component: an elk node. parentPos: {x:number, y:number} since elk coordinates are relative to the parent component */
            placeComponent = (component, parentPos) => {
                if (component.width === undefined) {
                    console.log("Unexpected missing width", component);
                }
                if (component.height === undefined) {
                    console.log("Unexpected missing height", component);
                }
                if (component.x === undefined) {
                    console.log("Unexpected missing x value", component);
                }
                if (component.y === undefined) {
                    console.log("Unexpected missing y value", component);
                }

                let absolutePos = { x: parentPos.x + component.x, y: parentPos.y + component.y }; // The absolute position of the componenet in the svg
                let componentData = {};
                if (component.i) {
                    componentData = component.i;
                }
                component.componentData = componentData;
                let componentName = componentData.name;

                let overRect;
                if (componentData.isMux) {
                    overRect = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                    let muxHeightOffset = 5/2;
                    let points = `${absolutePos.x},${absolutePos.y-muxHeightOffset} ${absolutePos.x+component.width},${absolutePos.y+muxHeightOffset} ${absolutePos.x+component.width},${absolutePos.y+component.height-muxHeightOffset} ${absolutePos.x},${absolutePos.y+component.height+muxHeightOffset}`;
                    overRect.setAttribute("points", points);
                } else {
                    overRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    overRect.setAttribute("x", absolutePos.x);
                    overRect.setAttribute("y", absolutePos.y);
                    overRect.setAttribute("width", component.width);
                    overRect.setAttribute("height", component.height);
                }
                for (let rect of [overRect]) {
                    rect.setAttribute("stroke", "black");
                    rect.setAttribute("stroke-width", Math.sqrt(component.height / 200)); //make the thickness proportional to the height so that it does not cover the under text
                    rect.setAttribute("fill", "white");
                }
                component.overRect = overRect;
                svgDisplay.appendChild(overRect);
                let overName = undefined;
                if (componentName.length > 0) {
                    let overName = fitText(componentName, {
                        x: absolutePos.x,
                        y: absolutePos.y,
                        width: component.width,
                        height: (component.children && component.children.length > 0 ) ? componentData.weight : component.height,
                    });
                    overName.setAttribute("pointer-events", "none");
                    // overName.setAttribute("fill", "blue");
                }

                //label ports
                component.portRects = [];
                if (component.ports) {
                    for (let port of component.ports) {
                        if (port.labels) {
                            let label = port.labels[0];
                            let portRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                            let x = absolutePos.x + port.x;
                            let y = absolutePos.y + port.y;
                            let width = port.width
                            let height = port.height
                            if (componentData.isMux) {
                                y -= 5/2;
                                width = 10;
                                height = 5;
                            } else {
                                for (let rect of [portRect]) {
                                    rect.setAttribute("x", x);
                                    rect.setAttribute("y", y);
                                    rect.setAttribute("width", width);
                                    rect.setAttribute("height", height);
                                    rect.setAttribute("stroke", "black");
                                    rect.setAttribute("stroke-width", Math.sqrt((component.height + component.width) / 1000)); //make the thickness proportional to the height so that it does not cover the under text
                                    rect.setAttribute("stroke-width", Math.sqrt(component.height / 200)); //make the thickness proportional to the height so that it does not cover the under text
                                    rect.setAttribute("fill", "white");
                                }
                                svgDisplay.appendChild(portRect);
                                component.portRects.push(portRect);
                            }
                            let portName = fitText(label.text, {
                                x: x,
                                y: y,
                                width: width,
                                height: height,
                            });
                            portName.setAttribute("pointer-events", "none");
                        }
                    }
                }

                // link component to source tokens
                if (componentData.tokensSourcedFrom) {
                    // jump to the corresponding text on click 
                    overRect.addEventListener("dblclick", () => {
                        jumpThroughSource(component, componentData.tokensSourcedFrom);
                    });
                    for (let portRect of component.portRects) {
                        portRect.addEventListener("dblclick", () => {
                            jumpThroughSource(component, componentData.tokensSourcedFrom);
                        });
                    }

                    let tokensToLink = componentData.tokensSourcedFrom;
                    for (filenameAndToken of tokensToLink) {
                        let filenameOfOrigin = filenameAndToken[0];
                        let tokenIndex = filenameAndToken[1];
                        let tokenSpan = sourceTokenAndWhitespaceSpanArrays.get(filenameOfOrigin)[tokenIndex];
                        tokenSpan.linkComponent(component, parentPos);
                    }
                    // highlight the associated tokens upon entering the box
                    overRect.addEventListener("mouseenter", () => {
                        clearHighlightedTokens();
                        highlightAssociatedTokens(component, tokensToLink);
                        clearHighlightedComponents();
                        highlightComponent(component);
                    });
                    for (let portRect of component.portRects) {
                        portRect.addEventListener("mouseenter", () => {
                            clearHighlightedTokens();
                            highlightAssociatedTokens(component, tokensToLink);
                            clearHighlightedComponents();
                            highlightComponent(component);
                        });
                    }
                    // clear box highlight upon exiting
                    overRect.addEventListener("mouseleave", () => {
                        clearHighlightedComponents();
                    });
                    for (let portRect of component.portRects) {
                        portRect.addEventListener("mouseleave", () => {
                            clearHighlightedComponents();
                        });
                    }
                }

                //place children and edges
                if (component.children) {
                    for (child of component.children) {
                        placeComponent(child, absolutePos);
                    }
                }
                if (component.edges) {
                    for (edge of component.edges) {
                        placeEdge(edge, absolutePos);
                    }
                }
            };

            /* edge: an elk edge. parentPos: {x:number, y:number} since elk coordinates are relative to the parent component */
            placeEdge = (edge, parentPos) => {
                let tokensToLink = edge.i.ts;
                edge.lines = [];
                edge.circles = [];
                let highlightEdge = () => {
                    for (let line of edge.lines) {
                        line.setAttribute("stroke", "green");
                        line.setAttribute("stroke-width", 3);
                        line.parentElement.appendChild(line);  // bring line to front
                    }
                    for (let circle of edge.circles) {
                        circle.setAttribute("fill", "green");
                        circle.setAttribute("r", 3);
                        circle.parentElement.appendChild(circle);  // bring circle to front
                    }
                }
                edge.highlightEdge = highlightEdge;
                let dehighlightEdge = () => {
                    for (let line of edge.lines) {
                        line.setAttribute("stroke", "blue");
                        line.setAttribute("stroke-width", 1);
                    }
                    for (let circle of edge.circles) {
                        circle.setAttribute("fill", "blue");
                        circle.setAttribute("r", 2);
                    }
                }
                edge.dehighlightEdge = dehighlightEdge;
                updateEdgeBBox = (box) => {
                    if (edge.bbox == undefined) {
                        edge.bbox = {x1: Math.min(box.x1, box.x2),
                                     y1: Math.min(box.y1, box.y2),
                                     x2: Math.max(box.x1, box.x2),
                                     y2: Math.max(box.y1, box.y2),
                                    };
                    } else {
                        edge.bbox = {x1: Math.min(edge.bbox.x1, box.x1, edge.bbox.x2, box.x2),
                                     y1: Math.min(edge.bbox.y1, box.y1, edge.bbox.y2, box.y2),
                                     x2: Math.max(edge.bbox.x1, box.x1, edge.bbox.x2, box.x2),
                                     y2: Math.max(edge.bbox.y1, box.y1, edge.bbox.y2, box.y2),
                                    };
                    }
                };
                let segments = []; //Array<{start:{x:number, y:number}, end:{x:number, y:number}}>
                if (edge.sections === undefined) {
                    // behavior should not occur
                    console.log("edge missing sections", edge);
                    return;
                }
                let currentLocation = edge.sections[0].startPoint; //walk along the edge and collect its segements
                if (edge.sections.length !== 1) {
                    console.log("Got an edge", edge, "with more than one section. This is unexpected.");
                }
                if (edge.sections[0].bendPoints) {
                    for (bendPoint of edge.sections[0].bendPoints) {
                        nextLocation = bendPoint;
                        segments.push({ start: currentLocation, end: nextLocation });
                        currentLocation = nextLocation;
                    }
                }
                segments.push({ start: currentLocation, end: edge.sections[0].endPoint });
                //draw the line segments of the edge
                for (let segment of segments) {
                    let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", parentPos.x + segment.start.x);
                    line.setAttribute("y1", parentPos.y + segment.start.y);
                    line.setAttribute("x2", parentPos.x + segment.end.x);
                    line.setAttribute("y2", parentPos.y + segment.end.y);
                    // line.setAttribute("stroke", "black");
                    line.setAttribute("stroke", "blue");
                    line.setAttribute("stroke-width", 1);
                    line.setAttribute("pointer-events", "none");
                    edge.lines.push(line);
                    svgDisplay.appendChild(line);

                    let lineInteract = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    lineInteract.setAttribute("x1", parentPos.x + segment.start.x);
                    lineInteract.setAttribute("y1", parentPos.y + segment.start.y);
                    lineInteract.setAttribute("x2", parentPos.x + segment.end.x);
                    lineInteract.setAttribute("y2", parentPos.y + segment.end.y);
                    lineInteract.setAttribute("stroke", "transparent");
                    lineInteract.setAttribute("stroke-width", 5);
                    svgDisplay.appendChild(lineInteract);

                    // set the wire inspect div to show the wire type, as well as token highlighting.
                    lineInteract.addEventListener("mouseenter", () => {
                        wireInspectDiv.style.visibility = "";
                        wireInspectDiv.innerHTML = edge.i.mt;
                        highlightEdge()
                        clearHighlightedTokens();
                        highlightAssociatedTokens(edge, tokensToLink);
                    });
                    lineInteract.addEventListener("mouseleave", () => {
                        wireInspectDiv.style.visibility = "hidden";
                        dehighlightEdge()
                        clearHighlightedTokens();
                    });
                    lineInteract.addEventListener('dblclick', () => {
                        clearHighlightedTokens();
                        highlightAssociatedTokens(edge, tokensToLink);
                        jumpThroughSource(edge, tokensToLink);
                    });

                    //update the edge's bounding box
                    updateEdgeBBox({x1: parentPos.x + segment.start.x,
                                    y1: parentPos.y + segment.start.y,
                                    x2: parentPos.x + segment.end.x,
                                    y2: parentPos.y + segment.end.y
                                    })
                }

                //draw circles at junction points
                if (edge.junctionPoints) {
                    for (let junction of edge.junctionPoints) {
                        let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        circle.setAttribute("cx", parentPos.x + junction.x);
                        circle.setAttribute("cy", parentPos.y + junction.y);
                        circle.setAttribute("r", 2);
                        circle.setAttribute("fill", "blue");
                        circle.setAttribute("pointer-events", "none");
                        edge.circles.push(circle);
                        svgDisplay.appendChild(circle);
                    }
                }

                //link the corresponding tokens
                for (filenameAndToken of tokensToLink) {
                    let filenameOfOrigin = filenameAndToken[0];
                    let tokenIndex = filenameAndToken[1];
                    let tokenSpan = sourceTokenAndWhitespaceSpanArrays.get(filenameOfOrigin)[tokenIndex];
                    tokenSpan.linkEdge(edge, parentPos);
                }
            };

            //place the top level component
            placeComponent(topLevel, { x: 0, y: 0 });

            /* Given a box with x, y, width, and height, moves the svg to show the box with
            a heuristically chosen amount of zoom. */
            showOffBox = (box) => {
                let size = Math.max(box.width, box.height);
                let marginPercent = 10 + 15*1000/(1+size);
                let margin = (size * marginPercent) / 100;
                destinationViewBox = [
                    -margin + box.x,
                    -margin + box.y,
                    box.width + 2 * margin,
                    box.height + 2 * margin,
                ];
                svgDisplay.setAttribute("viewBox", destinationViewBox.join(" "));
            }

            /* Given a component and its parent component's position,
            moves the svg view window to focus on the component. */
            jumpToComponent = (component, parentPos) => {
                showOffBox({x: component.x + parentPos.x,
                            y: component.y + parentPos.y,
                            width: component.width,
                            height: component.height
                        });
            };
            //set up the reset zoom button
            jumpToComponent(topLevel, { x: 0, y: 0 });
            document.getElementById("button-resetzoom-click-div").addEventListener("click", () => {
                jumpToComponent(topLevel, { x: 0, y: 0 });
            });

            jumpToEdge = (edge, parentPos) => {
                showOffBox({
                    x: edge.bbox.x1,
                    y: edge.bbox.y1,
                    width: edge.bbox.x2 - edge.bbox.x1,
                    height: edge.bbox.y2 - edge.bbox.y1
                });
            };

            //shrink any components' text boxes so that they fit inside the component
            fitAllText();
        </script>
    </body>
</html>
