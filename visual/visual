#!/usr/bin/python3

# This script will be called from the command line by the user. It will handle all file i/o.

# example call: ./../minispec/visual/visual eightbitcounter.ms EightBitCounter

# Run
#  export NODE_OPTIONS=--max_old_space_size=8192
# in case of a JavaScript heap out-of-memory error.
# See https://stackoverflow.com/questions/38558989/node-js-heap-out-of-memory for more info.

import argparse, os, pathlib

import synth
import hardware
from hardware import *

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("file", help="Minispec(.ms) file containing the function or module to view")
    parser.add_argument("target", help="Name of the function or module to synthesize")
    parser.add_argument("--visualdir", "-s", default="visualDir", help="Folder for intermediate visual files")
    parser.add_argument("--all", "-a", default=False, action="store_true", help="Layout all components recursively")
    args = parser.parse_args()

    if not os.path.exists(args.visualdir):
        print("Creating synthesis directory")
        os.makedirs(args.visualdir)
    else:
        # Clean up all files, as multi-module builds sometimes get stale data otherwise
        #run("rm -rf %s/*" % (args.visualdir,))
        pass #TODO erase files (currently not needed)

    currentPathString = os.getcwd()
    currentPath = pathlib.Path(currentPathString)
    targetFile = currentPath.joinpath(args.file)
    visualDir = pathlib.Path(args.visualdir)

    def pullTextFromImport(filename: 'str') -> 'str':
        ''' Given the name of a file to import (eg, filename = "fourbitcounter"), returns the text
        of the corresponding minispec file in the current directory (eg, the text of "/fourbitcounter.ms")
        and throws an error if no such file exists. '''
        textFile = pathlib.Path(targetFile).with_name(filename + ".ms")
        print('looking at file', textFile)
        return textFile.read_text()

    sourceFilename = pathlib.Path(args.file).stem
    targetText = pullTextFromImport(sourceFilename) 
    topLevel = args.target
    sourceFilesCollect = []
    print('synthing!!!')
    synthesizedComponent = synth.parseAndSynth(targetText, topLevel, sourceFilename, pullTextFromImport, sourceFilesCollect)
    print('synthed!!!')
    print(synthesizedComponent)

    if args.all:
        # Hardcode locations of all components recursively via ELKJS at compile time.

        # input/output files for elk
        pythonToJSFile = visualDir.joinpath("elkInput.txt")
        JSToPythonFile = visualDir.joinpath("elkOutput.txt")
        absoluteFilePath = pathlib.Path(__file__).resolve()
        ELKcaller = absoluteFilePath.with_name("elk").joinpath("place.js")


        # if not os.path.exists(JSToPythonFile):
        #     with JSToPythonFile.open('w') as fp: # create the output file if it does not exist
        #         pass

        with pythonToJSFile.open('w') as fp: # write to a file to give to elk
            fp.write(hardware.getELK(synthesizedComponent))

        print("elkcaller", ELKcaller)
        os.system(f"cd {visualDir} && node {ELKcaller}")

        elkOutput = JSToPythonFile.read_text() # the output from elk

        templateFile = pathlib.Path(__file__).with_name('template.html')
        template = templateFile.read_text()

        templateParts = template.split("/* Python data goes here */")
        numInsertionPoints = 2
        assert len(templateParts) == numInsertionPoints + 1, f"Expected {numInsertionPoints+1} segments from {numInsertionPoints} insertion points but found {len(templateParts)} segments instead."

        sourcesInfo = ''
        for sourceInfo in sourceFilesCollect:
            filename, text = sourceInfo
            sourcesInfo += f'''sources.set("{filename}", {{
            tokens: {synth.tokensAndWhitespace(text)}
        }});\n'''

        elementsToPlace = f'''elementsToPlace = {elkOutput}'''

        template = templateParts[0] + sourcesInfo + templateParts[1] + elementsToPlace + templateParts[2]

    else:
        # Layout components at page load.

        elkInput = hardware.getELK(synthesizedComponent) # the components to feed in

        templateFile = pathlib.Path(__file__).with_name('auto-place-template.html')
        template = templateFile.read_text()

        templateParts = template.split("/* Python data goes here */")
        numInsertionPoints = 2
        assert len(templateParts) == numInsertionPoints + 1, f"Expected {numInsertionPoints+1} segments from {numInsertionPoints} insertion points but found {len(templateParts)} segments instead."

        sourcesInfo = ''
        for sourceInfo in sourceFilesCollect:
            filename, text = sourceInfo
            sourcesInfo += f'''sources.set("{filename}", {{
            tokens: {synth.tokensAndWhitespace(text)}
        }});\n'''

        elementsToPlace = f'''elkInput = {elkInput}'''

        template = templateParts[0] + sourcesInfo + templateParts[1] + elementsToPlace + templateParts[2]

    # the equivalent of synths's sanitizeParametric
    outputFilename = topLevel.replace("#", "_").replace(",", "_").replace("(", "").replace(")", "").replace(" ", "").replace("\t", "")
    output = currentPath.joinpath(f'{outputFilename}.html')
    print(f"putting output into {output}")
    output.open("w").write(template)