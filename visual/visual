#!/usr/bin/python3

# This script will be called from the command line by the user. It will handle all file i/o.

# example call: ./../minispec/visual/visual eightbitcounter.ms EightBitCounter

# Run
#  export NODE_OPTIONS=--max_old_space_size=8192
# in case of a JavaScript heap out-of-memory error.
# See https://stackoverflow.com/questions/38558989/node-js-heap-out-of-memory for more info.

import argparse, os, pathlib
import time

import synth
import hardware
from hardware import *
from mtypes import *
import json

if __name__ == '__main__':
    total_start_time = time.time()

    parser = argparse.ArgumentParser()
    parser.add_argument("file", help="Minispec(.ms) file containing the function or module to view")
    parser.add_argument("target", help="Name of the function or module to synthesize")
    parser.add_argument("--visualdir", "-s", default="visualDir", help="Folder for intermediate visual files")
    parser.add_argument("--all", "-a", default=False, action="store_true", help="Layout all components recursively")
    parser.add_argument("--java", "-jv", default=False, action="store_true", help="Use the java version of elk")
    parser.add_argument("--canvas", "-c", default=False, action="store_true", help="Use the canvas element instead of the svg approach")
    parser.add_argument("--no_garbage_collection", "-ng", default=False, action="store_true", help="Do not remove unused hardware")
    parser.add_argument("--fixed_file", "-f", default=False, action="store_true", help="Generate an html document instead of launching a webserver")
    args = parser.parse_args()

    if not os.path.exists(args.visualdir):
        print("Creating synthesis directory")
        os.makedirs(args.visualdir)
    else:
        # Clean up all files, as multi-module builds sometimes get stale data otherwise
        #run("rm -rf %s/*" % (args.visualdir,))
        pass #TODO erase files (currently not needed)

    currentPathString = os.getcwd()
    currentPath = pathlib.Path(currentPathString)
    targetFile = currentPath.joinpath(args.file)
    visualDir = pathlib.Path(args.visualdir)

    synthesisStartTime = time.time()

    def pullTextFromImport(filename: 'str') -> 'str':
        ''' Given the name of a file to import (eg, filename = "fourbitcounter"), returns the text
        of the corresponding minispec file in the current directory (eg, the text of "/fourbitcounter.ms")
        and throws an error if no such file exists. '''
        textFile = pathlib.Path(targetFile).with_name(filename + ".ms")
        print('looking at file', textFile)
        return textFile.read_text()

    sourceFilename = pathlib.Path(args.file).stem
    targetText = pullTextFromImport(sourceFilename) 
    topLevel = args.target
    sourceFilesCollect = []
    print('Synthesizing to hardware representation ...')
    synth.folding_constants_through_function_defs = True
    synthesizedComponent = synth.parseAndSynth(targetText, topLevel, sourceFilename, pullTextFromImport, sourceFilesCollect)
    if not args.no_garbage_collection:
        hardware.garbageCollection1(synthesizedComponent)
    vacuumIntoVectors(synthesizedComponent)
    setWireTypes(synthesizedComponent)
    print(f'Synthesis complete. Time: {time.time() - synthesisStartTime} seconds')

    componentJson: 'dict[str, Any]' = hardware.getELK(synthesizedComponent)

    absoluteFilePath = pathlib.Path(__file__).resolve()

    if args.all:
        # Hardcode locations of all components recursively via ELKJS at compile time.

        # input/output files for elk
        pythonToJSFile = visualDir.joinpath("elkInput.txt")
        JSToPythonFile = visualDir.joinpath("elkOutput.txt")
        ELKcaller = absoluteFilePath.with_name("elk").joinpath("place.js")
        ELKJavacaller = absoluteFilePath.with_name("elkJava").joinpath("target/gs-maven-0.1.0.jar")

        # separate non-layout data before sending to library
        iFieldValues: 'dict[str, dict]' = {}  # maps element id's to python dictionaries
        def getIFieldValues(componentJson):
            # mutates componentJson
            if 'i' in componentJson:
                iFieldValues[componentJson['id']] = componentJson['i']
                del componentJson['i']
            if 'children' in componentJson:
                for child in componentJson['children']:
                    getIFieldValues(child)
            if 'edges' in componentJson:
                for edge in componentJson['edges']:
                    getIFieldValues(edge)
        getIFieldValues(componentJson)

        layoutStartTime = time.time()

        
        componentJsonString: 'str' = json.dumps(componentJson, separators=(',', ':'))
        with pythonToJSFile.open('w') as fp: # write to a file to give to elk
            fp.write(componentJsonString)
        # TODO investigate using a pipe to pass data around: https://stackoverflow.com/questions/29112324/piping-input-from-python-to-java

        if not args.java:
            # Use ELKJS to calculate the layout
            print("elkcaller", ELKcaller)
            print("Calculating layout ...")
            setJSHeapSize = 'export NODE_OPTIONS=--max_old_space_size=8192'  # otherwise we may run out of memory for large diagrams
            os.system(f"cd {visualDir} && {setJSHeapSize} && node {ELKcaller}")
            print(f"Layout complete. Time: {time.time() - layoutStartTime} seconds")
        else:
            # Use the java version of ELK to calculate the layout
            print("elkcaller", ELKJavacaller)
            print("Calculating layout ...")
            setJavaHeapSize = '-Xmx16g'  # otherwise we may run out of memory for large diagrams
            os.system(f"cd {visualDir} && java {setJavaHeapSize} -jar {ELKJavacaller}")
            print(f"Layout complete. Time: {time.time() - layoutStartTime} seconds")

        elkOutput = JSToPythonFile.read_text() # the output from elk

        elkOutputJson = json.loads(elkOutput)
        def stripExtraInfo(jsonObj):
            # removes now-unneeded layouting info from jsonObj
            # reduces output file size
            for property in ['layoutOptions', 'properties', '$H']:
                if property in jsonObj:
                    del jsonObj[property]
            if 'children' in jsonObj:
                for child in jsonObj['children']:
                    stripExtraInfo(child)
        stripExtraInfo(elkOutputJson)
        def restoreIFieldValues(elkOutputJson):
            # re-adds non-layout information into the component
            if elkOutputJson['id'] in iFieldValues:
                elkOutputJson['i'] = iFieldValues[elkOutputJson['id']]
            if 'children' in elkOutputJson:
                for child in elkOutputJson['children']:
                    restoreIFieldValues(child)
            if 'edges' in elkOutputJson:
                for edge in elkOutputJson['edges']:
                    restoreIFieldValues(edge)
        restoreIFieldValues(elkOutputJson)
        elkOutput = json.dumps(elkOutputJson, separators=(',', ':'))

        templateFile = pathlib.Path(__file__).with_name('template.html')
        if args.canvas:
            templateFile = pathlib.Path(__file__).with_name('canvas-template.html')
        template = templateFile.read_text()

        templateParts = template.split("/* Python data goes here */")
        numInsertionPoints = 2
        assert len(templateParts) == numInsertionPoints + 1, f"Expected {numInsertionPoints+1} segments from {numInsertionPoints} insertion points but found {len(templateParts)} segments instead."

        sourcesInfo = ''
        for sourceInfo in sourceFilesCollect:
            filename, text = sourceInfo
            sourcesInfo += f'''sources.set("{filename}", {{
            tokens: {synth.tokensAndWhitespace(text)[:-1]}
        }});\n'''

        elementsToPlace = f'''elementsToPlace = {elkOutput}'''

        template = templateParts[0] + sourcesInfo + templateParts[1] + elementsToPlace + templateParts[2]

    else:
        # Layout components at page load.
        raise Exception("This part of the program is not currently maintained; use the '-a' flag.")

        componentJsonString: 'str' = json.dumps(componentJson, separators=(',', ':')) # the components to feed in

        templateFile = pathlib.Path(__file__).with_name('auto-place-template.html')
        template = templateFile.read_text()

        templateParts = template.split("/* Python data goes here */")
        numInsertionPoints = 2
        assert len(templateParts) == numInsertionPoints + 1, f"Expected {numInsertionPoints+1} segments from {numInsertionPoints} insertion points but found {len(templateParts)} segments instead."

        sourcesInfo = ''
        for sourceInfo in sourceFilesCollect:
            filename, text = sourceInfo
            sourcesInfo += f'''sources.set("{filename}", {{
            tokens: {synth.tokensAndWhitespace(text)[:-1]}
        }});\n'''

        elementsToPlace = f'''elkInput = {componentJsonString}'''

        template = templateParts[0] + sourcesInfo + templateParts[1] + elementsToPlace + templateParts[2]

    # the equivalent of synths's sanitizeParametric
    outputFilename = topLevel.replace("#", "_").replace(",", "_").replace("(", "").replace(")", "").replace(" ", "").replace("\t", "")
    output = currentPath.joinpath(f'{outputFilename}.html')
    print(f"Putting output into {output}")
    output.open("w").write(template)

    print(f"Total time elapsed: {time.time() - total_start_time} seconds")

    if not args.fixed_file:
        serverCaller = absoluteFilePath.with_name("server.js")
        os.system(f'node {serverCaller} {output}')