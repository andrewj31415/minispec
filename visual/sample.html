<!DOCTYPE html>
<html>
    <head>
        <style>
            :root {
                --button-gray: rgb(192, 192, 192);
                font-size: 12pt;
            }
            html {
                height: 100vh;
                width: 100vw;
                overflow: hidden;
            }
            body {
                background-color: white;
                height: 100%;
                margin: 0;
            }
            #root {
                height: 100%;
                width: 100%;
                display: flex;
                flex-direction: row;
            }
            #source-div {
                position: relative;
                height: 100%;
                width: 35vw;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            #source-filenames-div {
                z-index: 100;
                width: 100%;
                background-color: rgb(220, 220, 220);
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                flex-shrink: 0;
            }
            .source-filename-div {
                padding: 10px;
                background-color: var(--button-gray);
                cursor: pointer;
            }
            #source-filetexts-div {
                position: relative;
                width: 100%;
                flex-grow: 1;
            }
            .source-file-div {
                z-index: 0;
                position: absolute;
                white-space: pre;
                overflow: auto;
                width: 100%;
                height: 100%;
                background-color: white;
            }
            #resize-div {
                height: 100%;
                width: 2px;
                background-color: black;
                cursor: e-resize;
            }
            #display-svg {
                object-fit: contain;
                flex: 2;
                cursor: default;
            }
            #control-button-div {
                width: 150px;
                height: 50px;
                position: absolute;
                bottom: 0;
                right: 0;
            }
            #button-fullscreen-background-div {
                z-index: 1;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 105px;
                background-color: var(--button-gray);
            }
            #button-fullscreen-image-embed {
                z-index: 2;
                position: absolute;
                width: 50px;
                height: 50px;
                top: 0px;
                left: 100px;
            }
            #button-fullscreen-click-div {
                z-index: 3;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 105px;
                background-color: transparent;
                cursor: pointer;
            }
            #button-resetzoom-image-embed {
                z-index: 2;
                position: absolute;
                width: 50px;
                height: 50px;
                top: 0px;
                left: 50px;
            }
            #button-resetzoom-background-div {
                z-index: 1;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 55px;
                background-color: var(--button-gray);
            }
            #button-resetzoom-click-div {
                z-index: 3;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 55px;
                background-color: transparent;
                cursor: pointer;
            }
            #button-help-image-embed {
                z-index: 2;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 5px;
            }
            #button-help-background-div {
                z-index: 1;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 5px;
                background-color: var(--button-gray);
            }
            #button-help-click-div {
                z-index: 3;
                position: absolute;
                width: 40px;
                height: 40px;
                top: 5px;
                left: 5px;
                background-color: transparent;
                cursor: pointer;
            }
            #help-div {
                /* See https://codepen.io/imprakash/pen/GgNMXO */
                position: absolute;
            }
            mark {
                background-color: rgb(130, 255, 157);
            }
        </style>
    </head>
    <body>
        <div id="root">
            <div id="source-div">
                <div id="source-filenames-div"></div>
                <div id="source-filetexts-div"></div>
            </div>
            <div id="resize-div" onmousedown="event.preventDefault(); /* prevents highlighting of source when resizing */"></div>
            <svg id="display-svg" viewBox="0 0 100 100"></svg>
            <div id="control-button-div">
                <div id="button-fullscreen-background-div"></div>
                <div id="button-resetzoom-background-div"></div>
                <div id="button-help-background-div"></div>
                <!-- Source: https://thenounproject.com/icon/reset-zoom-54041/ -->
                <embed
                    id="button-resetzoom-image-embed"
                    src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNzUycHQiIGhlaWdodD0iNzUycHQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDc1MiA3NTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiA8ZGVmcz4KICA8Y2xpcFBhdGggaWQ9ImEiPgogICA8cGF0aCBkPSJtMTQyIDE2OGg0NzAuNzl2NDMxaC00NzAuNzl6Ii8+CiAgPC9jbGlwUGF0aD4KIDwvZGVmcz4KIDxnIGNsaXAtcGF0aD0idXJsKCNhKSI+CiAgPHBhdGggZD0ibTYwNCA1MjQuNzVjLTAuMzA4NTktMC4yODUxNi0wLjY0NDUzLTAuNDMzNTktMC45MjE4OC0wLjY3OTY5bC04NS40MzgtODMuOTY5LTIxLjU1NS0yMS4xNzZjMjIuMDI3LTQ4LjQ3NyAyMi4xNDEtMTA2LjMtNC43OTY5LTE1Ni44LTQ2LjAwNC04Ni4xNTItMTUzLjUyLTExOC44NS0yMzkuNjctNzIuODc5LTEuODIwMyAwLjk2NDg0LTMuNTM5MSAyLjA1ODYtNS4zMTY0IDMuMDk3Ny0yNy43ODEgMTYuMDc4LTQ5LjY5NSAzOC42MzctNjQuNzE5IDY0LjgwNS05Ljk4NDQtNS4xMjUtMTcuMjE1LTkuNTcwMy0xOC4yNTQtMTAuMjM0IDAuOTgwNDcgMC42MzY3MiAwLjMxMjUgMC4wMzEyNS0wLjkxNzk3LTAuODQzNzUtMC44ODY3Mi0wLjc0MjE5LTEuODk0NS0xLjMyMDMtMi45OTIyLTEuODA4Ni0wLjQxNDA2LTAuMjEwOTQtMC44NTkzNy0wLjM4NjcyLTEuMjE0OC0wLjUwNzgxLTAuOTQ5MjItMC4yOTY4OC0xLjkyNTgtMC40MTQwNi0yLjg3NS0wLjQ0MTQxLTAuMjM0MzgtMC4wMzEyNS0wLjQxNDA2LTAuMDE1NjI1LTAuNjgzNTktMC4wMTU2MjUtMC44MjgxMiAwLjAxNTYyNS0xLjY1NjIgMC4xMDE1Ni0yLjQ2MDkgMC4yODEyNS0wLjA4OTg0NCAwLjAzMTI1LTAuMTc1NzggMC4wMzEyNS0wLjI2NTYzIDAuMDU4NTk0LTMuODc4OSAwLjk2NDg0LTcuMTk5MiAzLjg1MTYtOC40NTcgOC0wLjQ4ODI4IDEuNTI3My0wLjU3ODEyIDMuMDgyLTAuNDQxNDEgNC41OTM4IDAgMC0wLjA0Njg3NSAwLjA0Njg3NS0wLjAxNTYyNSAwLjA1ODU5M3YwLjAzMTI1YzAuMDMxMjUgMS4zMzIgMC4xNzU3OCAyLjc1MzkgMC41MzEyNSA0LjI2NTZsMTUuMzk4IDY2LjIwNyA0LjgxMjUgMjAuNzg1IDQuMjgxMiAxOC4zNDQgMS4zNzUgNS44OTQ1YzIuODE2NCAxMi4yNDIgMTIuNjUyIDE1LjIzIDIxLjg0IDYuNjQwNmwyMC41MDQtMTkuMTU2IDUuODA4Ni01LjQ1MzEgMTMuMzU5LTEyLjQ4OCA0MS4wNy0zOC40MTggMi42NTIzLTIuNDc2NmMwLjMxMjUtMC4yOTY4OCAwLjUxOTUzLTAuNTkzNzUgMC43ODUxNi0wLjg4NjcybDEuNzIyNy0xLjY5MTQtMC4xMjEwOS0wLjAzMTI1YzEuMDcwMy0xLjIxNDggMS45ODgzLTIuNjA1NSAyLjQ4ODMtNC4yMzgzIDAuMTM2NzItMC40Mjk2OSAwLjE3OTY5LTAuODU5MzggMC4yNjU2My0xLjI3MzQgMC43OTY4Ny0zLjE3MTkgMC4xNzU3OC02LjE5MTQtMS44MDg2LTguNzM4My0xLjQ2NDgtMi4xNzk3LTMuNjEzMy0zLjkxMDItNi4zMTI1LTQuNzI2NiAwIDAtMTUuOTY5IDEuMTA5NC0zOC45MzQtMy40ODQ0IDUuMzA0Ny03LjczMDUgMTEuNDk2LTE0LjkwMiAxOC41NDctMjEuMzc5IDcuNDk2MS02Ljg1OTQgMTUuOTQxLTEyLjkzNCAyNS4zMDUtMTcuOTI2IDE3LjU3NC05LjM2MzMgMzYuMzg3LTE0LjA0NyA1NS4wMjctMTQuNTIgNDUuNDg0LTEuMTY4IDg5Ljk4OCAyMi43NTQgMTEyLjg0IDY1LjU1OSAyOC45MTggNTQuMjIzIDEzLjM2MyAxMjAuNDgtMzMuODY3IDE1Ni43My0xLjY0MDYgMS4yNDYxLTMuMjg5MSAyLjQ3NjYtNC45NzY2IDMuNjQ4NC0wLjY1MjM0IDAuNDQxNDEtMS4zMDQ3IDAuODg2NzItMS45NTMxIDEuMzIwMy0wLjQxNDA2IDAuMjk2ODgtMC44NTkzOCAwLjU2MjUtMS4zMDQ3IDAuODQzNzUtMi4yMjI3IDEuNDQxNC00LjUzNTIgMi43NTM5LTYuODc1IDQuMDc0Mi0zMy45MyAxOC43MTUtNzYuMTIxIDIxLjM2My0xMTMuNjYgMy4zNTE2LTQuODkwNi0yLjM1OTQtOS41NDMtNS4wMzkxLTEzLjk4NC03Ljk0MTQtMS4yNzM0LTAuODMyMDMtMi41NjY0LTEuNjg3NS0zLjgyMDMtMi41NzgxLTAuOTE3OTctMC4yOTY4OC0xLjg2NzItMC41MDc4MS0yLjg5MDYtMC41MDc4MS0xLjY3NTggMC4wMzEyNS0zLjIxNDggMC41MTk1My00LjUzMTIgMS4zMzJsLTEuNzA3IDEuMzUxNi0yNy4xNDEgMjEuMTU2LTMuMTA5NCAyLjQxNDFjLTEuMjczNCAxLjUzOTEtMi4wNDY5IDMuNDg0NC0yLjA0NjkgNS42NDg0IDAuMDMxMjUgMS44MjAzIDAuNTkzNzUgMy41MTE3IDEuNTM5MSA0LjkxOCAxLjMzMiAxLjA4MiAyLjY5NTMgMi4xNjQxIDQuMDYyNSAzLjIxNDggOS4zOTA2IDcuMTg3NSAxOS42MTMgMTMuNTM5IDMwLjY4IDE4Ljg0NCAzOS4xMzMgMTguNzg5IDgxLjc3IDIxLjgyIDEyMC44MiAxMS43MzQgMC4xMTcxOSAwIDAuMjM0MzggMC4wNTg1OTQgMC4zODY3MiAwLjA1ODU5NCAxLjY1NjItMC40NDUzMSAzLjMzNTktMC44ODY3MiA0Ljk4MDUtMS4zNTk0IDExLjM0OC0zLjMyMDMgMjIuNTItNy43OTY5IDMzLjM2My0xMy41NzQgNC4zNjcyLTIuMzM5OCA4LjU2MjUtNC44NzUgMTIuNjgtNy41MjM0IDAuNTYyNS0wLjM1NTQ3IDEuMTQ0NS0wLjcwNzAzIDEuNzA3LTEuMDgyIDEuMTk5Mi0wLjc4NTE2IDIuMzU1NS0xLjYxNzIgMy41MzkxLTIuNDE0MSAwLjQxNDA2LTAuMjkyOTcgMC44MDg1OS0wLjU4NTk0IDEuMjE4OC0wLjg3MTA5bDE4LjE1MiAxNy44NzkgODIuNzM0IDgxLjI1NGMwLjE4MzU5IDAuMTg3NSAwLjMzNTk0IDAuNTAzOTEgMC41MjM0NCAwLjcwNzAzIDE0LjE1NiAxNC4wOTggNDAuMTA5IDEwLjk3MyA1OC4wMTItNyAxNy45NjUtMTcuOTQ1IDIxLjA5NC00My45NDUgNy4wMzEyLTU4LjAxMnoiLz4KIDwvZz4KPC9zdmc+Cg=="
                />
                <!-- Source: https://thenounproject.com/icon/fullscreen-1337699/ -->
                <embed
                    id="button-fullscreen-image-embed"
                    src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNzUycHQiIGhlaWdodD0iNzUycHQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDc1MiA3NTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiA8Zz4KICA8cGF0aCBkPSJtMTc4LjY4IDE3OC42OHYzOTQuNjVoMzk0LjY1di0zOTQuNjV6bTM1NS4xOSAzNTUuMTloLTMxNS43MnYtMzE1LjcyaDMxNS43MnoiLz4KICA8cGF0aCBkPSJtMzM2LjU0IDQ3NC42NmgtMzEuMjkzbDQ1LjI0Ni00NS4yNDYtMjcuOTAyLTI3LjkwMi00NS4yNDYgNDUuMjQ2di0zMS4yOTdoLTM5LjQ2NXY5OC42NjRoOTguNjZ6Ii8+CiAgPHBhdGggZD0ibTQyOS40MiAzNTAuNDkgNDUuMjQ2LTQ1LjI0NnYzMS4yOTNoMzkuNDY1di05OC42NmgtOTguNjY0djM5LjQ2NWgzMS4yOTdsLTQ1LjI0NiA0NS4yNDZ6Ii8+CiA8L2c+Cjwvc3ZnPgo="
                />
                <!-- Source: https://thenounproject.com/icon/help-2647215/ -->
                <embed
                    id="button-help-image-embed"
                    src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNzUycHQiIGhlaWdodD0iNzUycHQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDc1MiA3NTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiA8ZGVmcz4KICA8Y2xpcFBhdGggaWQ9ImIiPgogICA8cGF0aCBkPSJtMjE5IDEzOS4yMWgzMTR2MzI4Ljc5aC0zMTR6Ii8+CiAgPC9jbGlwUGF0aD4KICA8Y2xpcFBhdGggaWQ9ImEiPgogICA8cGF0aCBkPSJtMzEyIDUxMGgxMDN2MTAyLjc5aC0xMDN6Ii8+CiAgPC9jbGlwUGF0aD4KIDwvZGVmcz4KIDxnPgogIDxnIGNsaXAtcGF0aD0idXJsKCNiKSI+CiAgIDxwYXRoIGQ9Im0zNjguNTcgMTM5LjIxYzMwLjUyLTAuNDQ5MjIgNjAuODA1IDUuMzY3MiA4OC45ODQgMTcuMDk4IDIzLjg2NyA5LjU2MjUgNDQuMTAyIDI2LjQxOCA1Ny44MjQgNDguMTYgMTYuNjg4IDI3LjAyMyAyMS40NjkgNTkuNzM4IDEzLjIxNSA5MC40MS01LjIxMDkgMjEuMTIxLTE3Ljk5NiAzOC4xMjUtMzMuMTUyIDUzLjMyNC0xMi42NTIgMTEuOTY5LTI2LjE4OCAyMi45NzMtNDAuNDg4IDMyLjkxNC0xMC4zNzEgNy41NzgxLTIwLjUwOCAxNS41MzUtMzAuNTk0IDIzLjY4LTYuODQzOCA1Ljg2MzMtMTIuMDc4IDEzLjM3OS0xNS4yMDMgMjEuODMyLTIuNTU4NiA2LjAzMTItNS4wODIgMTIuMDc4LTcuNTc4MSAxOC4xMzctNS42ODM2IDE0LjU4Ni0xNy4xNDUgMjEuMjE1LTMyLjE1NiAyMi4xNjQtOS4xOTE0IDEuMjE0OC0xOC41MzEtMC42MzI4MS0yNi41NjYtNS4yNTc4LTYuNTIzNC00LjA3ODEtMTEuODItOS44NDM4LTE1LjMzMi0xNi42OTEtMy41MDc4LTYuODQzOC01LjEwMTYtMTQuNTEyLTQuNjA1NS0yMi4xODggMC41MTU2My0xOS4wMiA4LjExNzItMzcuMTU2IDIxLjMwOS01MC44NjMgMTQuNjMzLTE2LjYyMSAzMi43MjMtMjkuMjE5IDQ5Ljg2Ny00Mi45MDZoMC4wMDM5MDZjMTMuMjk3LTkuNjUyMyAyNC43NjItMjEuNjAyIDMzLjg1OS0zNS4yODEgMTIuNDU3LTIwLjYwMiA4LjU3MDMtNTQuNDYxLTEyLjY0NS02OS40NzN2LTAuMDAzOTA2Yy03LjY2OC01LjM5NDUtMTYuNDYxLTguOTcyNy0yNS43MTUtMTAuNDY1LTE0LjA5OC0yLjYzNjctMjguNjI1LTEuODI0Mi00Mi4zNCAyLjM2NzItMTUuOTE0IDUuMDE5NS0yNi4wOTQgMTYuNTc0LTMzLjU3OCAzMC45NzMtNS40NDUzIDEwLjUxMi0xMC4zMjQgMjEuNDA2LTE2LjU3NCAzMS40NDUtMTAuNTEyIDE2Ljk1My0yOC4wODIgMjAuNjQ4LTQ1Ljc0NiAxNy40M3YtMC4wMDM5MDZjLTcuNzA3LTEuMjA3LTE0Ljg4My00LjY4MzYtMjAuNjAyLTkuOTkyMi03LjY3NTgtNy41MjM0LTExLjcwMy0xOC4wMTYtMTEuMDM1LTI4Ljc0NiAwLjI3NzM0LTE4LjMwMSA2LjAzNTItMzYuMTAyIDE2LjUyNy01MS4wOTggMTcuNjI1LTI1LjMyOCA0Mi42NTItNDQuNTg2IDcxLjY1Ni01NS4xMjUgMTkuMzc1LTcuNDYwOSAzOS45MDYtMTEuNDY5IDYwLjY2NC0xMS44NHoiLz4KICA8L2c+CiAgPGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj4KICAgPHBhdGggZD0ibTQxNC42IDU2MS42YzAgMjguMjczLTIyLjkxOCA1MS4xOTUtNTEuMTk1IDUxLjE5NS0yOC4yNzMgMC01MS4xOTEtMjIuOTIyLTUxLjE5MS01MS4xOTUgMC0yOC4yNzMgMjIuOTE4LTUxLjE5NSA1MS4xOTEtNTEuMTk1IDI4LjI3NyAwIDUxLjE5NSAyMi45MjIgNTEuMTk1IDUxLjE5NSIvPgogIDwvZz4KIDwvZz4KPC9zdmc+Cg=="
                />
                <div id="button-fullscreen-click-div" onclick="document.documentElement.requestFullscreen()"></div>
                <div id="button-resetzoom-click-div" onclick="svgDisplay.setAttribute('viewBox', '0 0 100 100')"></div>
                <div
                    id="button-help-click-div"
                    onclick="console.log('Asking for help!')"
                    onmousedown="event.preventDefault(); /* prevents highlighting of div when clicking on icon */"
                ></div>
            </div>
        </div>
        <script defer>
            /* Globals */
            sourceDisplay = document.getElementById("source-div"); //The div with the source code
            sourceFilenameDisplay = document.getElementById("source-filenames-div"); //The div with the clickable filenames
            sourceFiletextDisplay = document.getElementById("source-filetexts-div"); //The div with the text of the files
            resizeDiv = document.getElementById("resize-div"); //The bar for resizing the display
            svgDisplay = document.getElementById("display-svg"); //The svg with the diagram
            startingFontSize = 100; //in pt
            fontShrinkFactor = 0.75; //all fonts will have size startingFontSize*(fontShrinkFactor)^k for some integer k
            getSVGViewBox = () =>
                svgDisplay
                    .getAttribute("viewBox")
                    .split(" ")
                    .map((item) => Number(item)); //returns the viewbox of svgDisplay as an array of four numbers.

            /* Given a mouse event from an event listener, returns {x: number, y: number}
                            where x and y are the svg coordinates of the click on svgDisplay.
                            See https://stackoverflow.com/questions/29261304/how-to-get-the-click-coordinates-relative-to-svg-element-holding-the-onclick-lis
                        */
            getSVGCoordinates = (event) => {
                let pt = svgDisplay.createSVGPoint();
                pt.x = event.clientX;
                pt.y = event.clientY;
                let cursorpt = pt.matrixTransform(svgDisplay.getScreenCTM().inverse());
                return cursorpt;
            };

            /* Allow the user to zoom in/out on the svg by scrolling. */
            svgDisplay.addEventListener("wheel", (e) => {
                let coords = getSVGCoordinates(e);
                let rescaleFactor = 2 ** (e.deltaY / 100);
                let currentSVGViewBox = getSVGViewBox();
                currentSVGViewBox = [
                    currentSVGViewBox[0] * rescaleFactor + coords.x * (1 - rescaleFactor),
                    currentSVGViewBox[1] * rescaleFactor + coords.y * (1 - rescaleFactor),
                    currentSVGViewBox[2] * rescaleFactor,
                    currentSVGViewBox[3] * rescaleFactor,
                ];
                svgDisplay.setAttribute("viewBox", currentSVGViewBox.join(" "));
            });

            /* Allow the user to click to zoom and drag to move
                            See https://www.petercollingridge.co.uk/tutorials/svg/interactive/dragging/
                        */
            isSVGDragging = false;
            startSVGDragging = (event) => {
                isSVGDragging = true;
                let coords = getSVGCoordinates(event);
                svgDraggingX = coords.x;
                svgDraggingY = coords.y;
            };
            stopSVGDragging = () => {
                isSVGDragging = false;
            };
            svgDisplay.addEventListener("mousedown", startSVGDragging);
            window.addEventListener("mouseup", stopSVGDragging);
            window.addEventListener("mousemove", (event) => {
                if (isSVGDragging) {
                    let newCoords = getSVGCoordinates(event);
                    let currentSVGViewBox = getSVGViewBox();
                    currentSVGViewBox = [
                        currentSVGViewBox[0] + svgDraggingX - newCoords.x,
                        currentSVGViewBox[1] + svgDraggingY - newCoords.y,
                        currentSVGViewBox[2],
                        currentSVGViewBox[3],
                    ];
                    svgDisplay.setAttribute("viewBox", currentSVGViewBox.join(" "));
                }
            });

            /* Allow the user to resize the text display/svg display.
                            See https://medium.com/the-z/making-a-resizable-div-in-js-is-not-easy-as-you-think-bda19a1bc53d */
            isResizing = false;
            startResize = (event) => {
                isResizing = true;
            };
            stopResize = () => {
                isResizing = false;
            };
            resizeDiv.addEventListener("mousedown", startResize);
            window.addEventListener("mouseup", stopResize);
            window.addEventListener("mousemove", (event) => {
                if (isResizing) {
                    sourceDisplay.style.width = event.pageX + "px";
                }
            });

            /* Takes in a line of text and an object with x, y, width, and height attributes.
                        Fits the text to the box, adds it to the DOM, and returns a reference to the resulting
                        DOM object.
                        Shrinks the font size to fit vertically. */
            fitText = (text, element) => {
                let textBox = document.createElementNS("http://www.w3.org/2000/svg", "text");
                textBox.innerHTML = text;
                textBox.setAttribute("x", element.x + element.width / 2);
                textBox.setAttribute("y", element.y + element.height / 2);
                textBox.setAttribute("dominant-baseline", "middle");
                textBox.setAttribute("text-anchor", "middle");
                textBox.setAttribute("font-size", String(startingFontSize) + "pt");
                textBox.style.userSelect = "none";
                svgDisplay.appendChild(textBox);

                //fix the font size to fit vertically
                let currentSize = startingFontSize;
                while (textBox.getBBox().height > element.height) {
                    currentSize = currentSize * fontShrinkFactor;
                    textBox.setAttribute("font-size", String(currentSize) + "pt");
                }

                //use ellipses to shrink the text horizontally, leaving at least two letters behind
                if (textBox.getBBox().width > element.width) {
                    textBox.innerHTML += "...";
                    while (textBox.getBBox().width > element.width && textBox.innerHTML.length > 5) {
                        //remove the last letter before the ellipses
                        textBox.innerHTML = textBox.innerHTML.slice(0, -4) + "...";
                    }
                }
                return textBox;
            };

            /* Sources will be stored using sources: Map<filename: string, { text: string, color: Array<string> }> */

            sources = new Map();
            sources.set("fourbitcounter", {
                text: `import twobitcounter

module FourBitCounter;
    TwoBitCounter lower;
    TwoBitCounter upper;
    method Bit#(4) getCount;
        return {upper.getCount, lower.getCount};
    endmethod
    input Bool enable;
    rule increment;
        lower.enable = enable;
        upper.enable = enable && (lower.getCount == 3);
    endrule
endmodule
`,
                color: [
                    ...Array(6).fill("blue"),
                    "pink",
                    ...Array(13).fill("black"),
                    "pink",
                    "pink",
                    ...Array(6).fill("blue"),
                    "pink",
                    ...Array(14).fill("black"),
                    ...Array(1).fill("black"),
                    ...Array(5).fill("pink"),
                    ...Array(13).fill("black"),
                    "pink",
                    ...Array(5).fill("black"),
                    ...Array(1).fill("black"),
                    ...Array(5).fill("pink"),
                    ...Array(13).fill("black"),
                    "pink",
                    ...Array(5).fill("black"),
                    ...Array(1).fill("black"),
                    ...Array(5).fill("pink"),
                    ...Array(6).fill("blue"),
                    "pink",
                ],
            });
            sources.set("twobitcounter", {
                text: `
module TwoBitCounter;
    Reg#(Bit#(2)) count(0);
    method Bit#(2) getCount = count;
    input Bool enable;
    rule increment;
        if (enable)
            count <= count + 1;
    endrule
endmodule
`,
                color: [],
            });
            sources.set("big file", {
                text: `import ProcTypes;

import RegisterFile;
import Decode;
import Execute;

import ALU;

// MainMemory includes the MainMemory port
// and the SingleCycleMemory modules
import MainMemory;

// Milestone 2: Select which cache(s) to import
import DirectMappedCache;
import TwoWayCache;
import SimpleCache;

// Types associated with the fetch stage
typedef enum {
    Dequeue, // Consume instruction at the f2d output, if any
    Stall, // Do not consume instruction at f2d
    Redirect,  // Redirect fetch to another PC, annulling any fetched instructions
    Shuffle
} FetchAction;

typedef struct {
    FetchAction fetchAction;
    Word redirectPC;  // PC to fetch from, used only if fetchAction is Redirect
} FetchInput;


typedef struct {
    Word pc;
    Word inst;
} F2D;

typedef struct {
    Word pc;
    DecodedInst dInst;
    Word rVal1;
    Word rVal2;
    // Add anything you need
} D2E;

typedef struct {
    Word pc;
    DecodedInst dInst;
    Word rVal1;
    Word rVal2;
    // Add anything you need
    RIndx src1;
    RIndx src2;
} D2E2;

typedef struct {
    Word pc;
    IType iType;
    Maybe#(RIndx) dst;
    Word data;
    // Add anything you need
} E2W;


// Fetch stage, including pc and instruction memory/cache
// 
// See handout for the structure of the recommended fetch stage. You can test
// this module using FetchTB (ms sim FetchTB.ms FetchTB).
//
// Implementing this module is optional: you can place the fetch logic and
// iMem/iCache inside the processor instead. We recommend you use a separate
// module at least during Part 2 to ease debugging.
module Fetch;
    Reg#(Word) pc(0);

    Reg#(Bool) skipNextInsts(False);
    Reg#(Bool) atCacheLineEnd(False);

    // Single-cycle Instruction Memory
    // Milestone 2: comment this declaration out
    //SingleCycleMemory iMem;
    
    // Line-based Main Memory to use with caches
    // Milestone 2: uncomment this declaration
    MainMemory iMem;

    // Milestone 2: choose which type of iCache to use
    //DirectMappedCache iCache(iMem);
    //TwoWayCache iCache(iMem);
    SimpleCache iCache(iMem);

    input FetchInput in;

    // Milestone 2: Modify to use iCache instead
    method Maybe#(F2D) f2d = skipNextInsts ? Invalid : (isValid(iCache.data)?
        Valid(F2D{pc: pc, inst: fromMaybe(?, iCache.data)}) : Invalid);

    method Maybe#(F2D) f2d2 = skipNextInsts ? Invalid : (isValid(iCache.data2)?
        Valid(F2D{pc: fastAdd#(32)(pc, 4, 0), inst: fromMaybe(?, iCache.data2)}) : Invalid);


    rule fetch;
        // Fetch instructions from iMem/iCache and update PC according to in.
        //////////////////////////
        // TODO: Your code here //
        //////////////////////////
//$display("Offset: %h", getWordOffset(pc));
        case (in.fetchAction)
            Dequeue: begin
//$display("Dequeue pc = %h", pc);
              if (iCache.reqEnabled) begin
                iCache.req = Valid(MemReq{addr: fastAdd#(32)(pc, atCacheLineEnd ? 4:8, 0), op: Ld, data: ?});
              end
              pc <= fastAdd#(32)(pc, atCacheLineEnd ? 4:8, 0);
              atCacheLineEnd <= getWordOffset(fastAdd#(32)(pc, atCacheLineEnd ? 4:8, 0)) == wordsPerLine-1;
//$display("next pc: %h", fastAdd#(32)(pc, getWordOffset(pc) != wordsPerLine-1 ? 8:4, 0));
            end
            Stall: begin
//$display("Stall pc = %h", pc);
              if (iCache.reqEnabled) begin
                iCache.req = Valid(MemReq{addr: pc, op: Ld, data: ?});
              end
            end
            Shuffle: begin
              if (iCache.reqEnabled) begin
                iCache.req = Valid(MemReq{addr: fastAdd#(32)(pc, 4, 0), op: Ld, data: ?});
              end
              pc <= fastAdd#(32)(pc, 4, 0); 
              atCacheLineEnd <= getWordOffset(fastAdd#(32)(pc, 4, 0)) == wordsPerLine-1;
            end
            Redirect: begin
              if (iCache.reqEnabled) begin
                iCache.req = Valid(MemReq{addr: in.redirectPC, op: Ld, data: ?});
              end
              pc <= in.redirectPC;
              atCacheLineEnd <= getWordOffset(in.redirectPC) == wordsPerLine-1;
            end
        endcase

if (in.fetchAction == Redirect) skipNextInsts <= True;
else if (isValid(iCache.data)) skipNextInsts <= False;

    endrule

    // Used only for pipeline debugging; you should not use this method
    // elsewhere in your code (assume the fetch stage can run ahead)
    method Word getPc = pc;
    method Word getPc2 = fastAdd#(32)(pc, 4, 0); 
endmodule


module Processor;
    Fetch fetch;

    RegisterFile rf;

    // Single-cycle data memory
    // Milestone 2: comment this declaration out
    //SingleCycleMemory dMem;

    // Line-based Main Memory to use with caches
    // Milestone 2: uncomment this declaration
    MainMemory dMem;

    // Milestone 2: choose which type of data cache to use
    // NOTE: The CacheWrapper#() type of the dCache is critical, as it is used
    // for detecting that the program has finished running
    CacheWrapper#(DirectMappedCache) dCache(dMem);
    //CacheWrapper#(TwoWayCache) dCache(dMem);

    //Print printer;
    //Print printer2;

    // Pipeline Registers
    Reg#(Maybe#(D2E)) d2e(Invalid);
    Reg#(Maybe#(E2W)) e2w(Invalid);

    Reg#(Maybe#(D2E2)) d2e2(Invalid);
    Reg#(Maybe#(E2W)) e2w2(Invalid);


    // Performance counters
    // These are used in the processor rule for debugging help, by tracking the
    // cycles and instructions completed. They are not needed for correctness
    // and you may remove them, but doing so is unlikely to reduce cycle time.
    Reg#(Bit#(32)) cycle(0);
    Reg#(Bit#(32)) instrs(0);
    Reg#(Bit#(32)) instrs1(0);
    Reg#(Bit#(32)) instrs2(0);

    rule tick;
        //////////////////////
        // Debugging Helper //
        //////////////////////
        cycle <= cycle + 1;
        // Uncomment the code below to print pipeline state each cycle
        begin
            $write("[%d] F|D|E|W PCs: ", cycle);
            $write("%x|", fetch.getPc);
            if (isValid(fetch.f2d)) $write("%x|", fromMaybe(?, fetch.f2d).pc); else $write("%8s|", "NOP");
            if (isValid(d2e)) $write("%x|", fromMaybe(?, d2e).pc); else $write("%8s|", "NOP");
            if (isValid(e2w)) $write("%x", fromMaybe(?, e2w).pc); else $write("%8s", "NOP");
            $display("  instrs: %d", instrs);
        end
        begin
            $write("[%d] F|D|E|W PCs: ", cycle);
            $write("%x|", fetch.getPc2);
            if (isValid(fetch.f2d2)) $write("%x|", fromMaybe(?, fetch.f2d2).pc); else $write("%8s|", "NOP");
            if (isValid(d2e2)) $write("%x|", fromMaybe(?, d2e2).pc); else $write("%8s|", "NOP");
            if (isValid(e2w2)) $write("%x", fromMaybe(?, e2w2).pc); else $write("%8s", "NOP");
            $display("  instrs: %d", instrs);
        end


        /////////////////////
        // Writeback Stage //
        /////////////////////
        // Signals used by decode to handle data hazards
        RIndx dstW = 0;
        Word dataW = 0;
        RIndx dstW2 = 0;
        Word dataW2 = 0;

        // Signal for dCache-induced stalls
        Bool dStall = False;
        Bool dStall2 = False;


        if (isValid(e2w)) begin
            let e2w_v = fromMaybe(?, e2w);
            //////////////////
            // Writeback #1 //
            //////////////////
//$display("Writing back for instruction of type: ", fshow(e2w_v.iType));

            Word dataToWrite = e2w_v.data;
            //Pick up data from a load if necessary
            if (e2w_v.iType == LOAD) begin
                if (isValid(dCache.data)) begin
                    dataToWrite = fromMaybe(0, dCache.data);  //get the data from memory if we are loading
//$display("Loaded data: %h to store in %h", dataToWrite, fromMaybe(0, e2w_v.dst));
                end else begin
                    dStall = True;  //if our dCache has not returned any data, we need to stall until it does.
//$display("Read stalling");
                end
            end

            // Write to a register if the instruction requires it
            if (isValid(e2w_v.dst)) begin
                rf.wr = Valid(RegWriteArgs{index: fromMaybe(?, e2w_v.dst), data: dataToWrite});
//$display("Writing %h to %d", dataToWrite, fromMaybe(?, e2w_v.dst));
                dstW = fromMaybe(0, e2w_v.dst);  //note the register being written to for the purpose of data hazards
                dataW = dstW == 0 ? 0 : dataToWrite;
            end

            // Count every instruction that leaves the writeback stage
            // (for debugging help)
            instrs1 <= instrs1 + 1;

            // BEGIN: DO NOT REMOVE OR MODIFY THIS CODE
            // If unsupported instruction, stops simulation and print the state of the processor
            if (e2w_v.iType == Unsupported) begin
                $display("Reached unsupported instruction");
                $display("Dumping the state of the processor");
                $display("pc = 0x%x", e2w_v.pc);
                $display(rf.fshow);
                $display("Quitting simulation.");
                $finish;
            end
            // END: DO NOT REMOVE OR MODIFY THIS CODE
        end

        if (isValid(e2w2)) begin
            let e2w2_v = fromMaybe(?, e2w2);
            //////////////////
            // Writeback #2 //
            //////////////////
//$display("Writing back for instruction of type: ", fshow(e2w2_v.iType));

            Word dataToWrite2 = e2w2_v.data;
            //Pick up data from a load if necessary
            if (e2w2_v.iType == LOAD && !dStall ) begin  //if the other pipeline is dStalled, we can't load data
                if (isValid(dCache.data)) begin
                    dataToWrite2 = fromMaybe(0, dCache.data);  //get the data from memory if we are loading
//$display("Loaded data2: %h to store in %h", dataToWrite2, fromMaybe(0, e2w2_v.dst));
                end else begin
                    dStall2 = True;  //if our dCache has not returned any data, we need to stall until it does.
//$display("Read stalling");
                end
            end

            //write to a register if necessary
            if (isValid(e2w2_v.dst)) begin
                rf.wr2 = Valid(RegWriteArgs{index: fromMaybe(?, e2w2_v.dst), data: dataToWrite2});
//$display("Writing2 %h to %d", dataToWrite2, fromMaybe(?, e2w2_v.dst));
                dstW2 = fromMaybe(0, e2w2_v.dst);  //note the register being written to for the purpose of data hazards
                dataW2 = dstW2 == 0 ? 0 : dataToWrite2;
            end

            // Count every instruction that leaves the writeback stage
            // (for debugging help)
            instrs2 <= instrs2 + 1;

        end
        instrs <= instrs1 + instrs2;

        ///////////////////
        // Execute Stage //
        ///////////////////
        // Signal for decode stalls or 2nd exec stall
        Bool stall = False;

        // Signals used to handle mispredictions
        Bool annulAfterExec = False;
        Bool annulAfterExec2 = False;
        Word redirectPC = ?;

        // Signals used by decode to handle data hazards
        RIndx dstE = 0;
        Word dataE = 0;
        RIndx dstE2 = 0;
        Word dataE2 = 0;
        RIndx loadInto = 0;  //stall a cycle if loading
        RIndx loadInto2 = 0;  //stall a cycle if loading on the second instruction
        Bool reqStall = False; //exec is waiting for the dCache to have reqEnable.
        Bool reqStall2 = False; //exec2 is waiting for the dCache to have reqEnable.
        Bool makingReq = False; //exec is sending a request to the dCache

        if (isValid(d2e)) begin
            let d2e_v = fromMaybe(?, d2e);
            ////////////////
            // Execute #1 //
            ////////////////
            Word rVal1 = d2e_v.rVal1;
            Word rVal2 = d2e_v.rVal2;
            ExecInst eInst = execute( d2e_v.dInst, rVal1, rVal2, d2e_v.pc);

//$display("Using: ", fshow(eInst.iType));
//$display("Combined rVal1: %h, rVal2: %h, imm: %h to get %h to put into %h", rVal1, rVal2, d2e_v.dInst.imm, eInst.data, fromMaybe(0, eInst.dst));

            //send load and store requests to memory
            if (eInst.iType == LOAD) begin
                loadInto = fromMaybe(0, eInst.dst);
                if (dCache.reqEnabled) begin
                    dCache.req = Valid(MemReq{addr: eInst.addr, op: Ld, data: ?});
                    makingReq = True;
//$display("Requesting load data from %h", eInst.addr);
                end else begin
                    reqStall = True;
//$display("Req stalling to load");
                end
            end else if (eInst.iType == STORE) begin
                if (dCache.reqEnabled) begin
                    dCache.req = Valid(MemReq{addr: eInst.addr, op: St, data: eInst.data});
                    makingReq = True;
//$display("Requesting store data: %h into %h", eInst.data, eInst.addr);
                end else begin
                    reqStall = True;
//$display("Req stalling to store");
                end
            end


            //assign e2w
            if (dStall) begin
                //do nothing
            end else if (dStall2 || reqStall) begin
                e2w <= Invalid;
            end else if (isValid(e2w2) && fromMaybe(?, e2w2).iType == Unsupported) begin  //handle end of program
                e2w <= Valid(E2W{pc: fromMaybe(?, e2w2).pc, iType: Unsupported, dst: ?, data: ?});
//$display("Second pipeline crash detected");
            end else begin
                e2w <= Valid(E2W{pc: d2e_v.pc, iType: eInst.iType, dst: eInst.dst, data: eInst.data});
            end

            dstE = fromMaybe(0, d2e_v.dInst.dst);  //note the register being written to for the purpose of data hazards
            dataE = dstE == 0 ? 0 : eInst.data;


            if (eInst.nextPc != (fastAdd#(32)(d2e_v.pc,4,0))) begin  //if we are going somewhere other than pc+4, annul.
                annulAfterExec = True;
                redirectPC = eInst.nextPc;
            end


        end else begin
            //assign e2w
            if (dStall) begin
                //do nothing
            end else if (isValid(e2w2) && fromMaybe(?, e2w2).iType == Unsupported) begin  //handle end of program
                e2w <= Valid(E2W{pc: fromMaybe(?, e2w2).pc, iType: Unsupported, dst: ?, data: ?});
//$display("Second pipeline crash detected");
            end else begin
                e2w <= Invalid;
            end
        end

        if (isValid(d2e2)) begin
            let d2e2_v = fromMaybe(?, d2e2);
            ////////////////
            // Execute #2 //
            ////////////////
            Word rVal12 = d2e2_v.rVal1;
            Word rVal22 = d2e2_v.rVal2;

            ExecInst eInst2 = execute( d2e2_v.dInst, rVal12, rVal22, d2e2_v.pc);
//$display("Using: ", fshow(eInst2.iType));
//$display("Combined2 rVal1: %h, rVal2: %h, imm: %h to get %h to put into %h", rVal12, rVal22, d2e2_v.dInst.imm, eInst2.data, fromMaybe(?, eInst2.dst));
            //send load and store requests to memory
            if (eInst2.iType == LOAD) begin
                loadInto2 = fromMaybe(0, eInst2.dst);
                if (dCache.reqEnabled && !makingReq) begin
                    dCache.req = Valid(MemReq{addr: eInst2.addr, op: Ld, data: ?});
//$display("Requesting load data2");
                end else begin
                    reqStall2 = True;
//$display("Req stalling2");
                end
            end else if (eInst2.iType == STORE) begin
                if (dCache.reqEnabled && !makingReq) begin
                    dCache.req = Valid(MemReq{addr: eInst2.addr, op: St, data: eInst2.data});
//$display("Requesting store data2: %h", eInst2.data);
                end else begin
                    reqStall2 = True;
//$display("Req stalling2");
                end
            end

            //assign e2w2
            if (dStall || dStall2) begin
                //do nothing, just wait
            end else if (reqStall || reqStall2 || annulAfterExec) begin
                e2w2 <= Invalid;
            end else begin
                e2w2 <= Valid(E2W{pc: d2e2_v.pc, iType: eInst2.iType, dst: eInst2.dst, data: eInst2.data});
            end

            dstE2 = fromMaybe(0, d2e2_v.dInst.dst);  //note the register being written to for the purpose of data hazards
            dataE2 = dstE2 == 0 ? 0 : eInst2.data;

            if (eInst2.nextPc != (fastAdd#(32)(d2e2_v.pc,4,0)) && !annulAfterExec ) begin  //if we are going somewhere other than pc+4, annul.
                annulAfterExec2 = True;
                redirectPC = eInst2.nextPc;
            end

        end else begin
            if (dStall || dStall2) begin
                //do nothing
            end else begin
                e2w2 <= Invalid;
            end
        end


        //////////////////
        // Decode Stage //
        //////////////////
        Bool decodeStall = False;  //if decode does not receive an instruction, stall fetch.

        //for detecting conflicting instructions
        Bool consecExecStall = False;  //if we have two instructions whose execute stages depend on each other
        RIndx dstD = 0;  //the destination of the first instruction, or 0 if there is no destination

        //for handling a stall for load cycles
        Bool loadStall = False;  //true if we are executing a load in exec and we need the data in decode
        Bool loadStall2 = False;  //""  "" need the data in decode2

        Bool branchOrJumpInDecode = False; //true if there is a branch instruction in decode, since we do not allow a branch followed by a store.

        if (isValid(fetch.f2d)) begin
            let f2d_v = fromMaybe(?, fetch.f2d);
            ///////////////
            // Decode #1 //
            ///////////////

            DecodedInst dInst = decode(f2d_v.inst);
            Word rVal1 = rf.rd1(dInst.src1);
            Word rVal2 = rf.rd2(dInst.src2);

//$display("DECODED: src1: %d, src2: %d, dst: %d", dInst.src1, dInst.src2, fromMaybe(0, dInst.dst));
//$display("ITYPE: ", fshow(dInst.iType));
//$display("inst: %b", f2d_v.inst);
//printer.toString = Valid(dInst);

            //bypass logic
            if (dstW == dInst.src1) rVal1 = dataW;
            if (dstW == dInst.src2) rVal2 = dataW;
            if (dstW2 == dInst.src1) rVal1 = dataW2;
            if (dstW2 == dInst.src2) rVal2 = dataW2;
            if (dstE == dInst.src1) rVal1 = dataE;
            if (dstE == dInst.src2) rVal2 = dataE;
            if (dstE2 == dInst.src1) rVal1 = dataE2;
            if (dstE2 == dInst.src2) rVal2 = dataE2;

            if (loadInto != 0 && (loadInto == dInst.src1 || loadInto == dInst.src2)) loadStall = True;
            if (loadInto2 != 0 && (loadInto2 == dInst.src1 || loadInto2 == dInst.src2)) loadStall = True;

            //destination for decode
            dstD = fromMaybe(0, dInst.dst);

            //might our instruction cause a jump?
            if (dInst.iType == BRANCH || dInst.iType == JAL || dInst.iType == JALR) branchOrJumpInDecode = True;

            //assign d2e
            if (dStall || dStall2 || reqStall || annulAfterExec2) begin  //note that loadStall2 is not yet determined/known.
                //do nothing, just wait
            end else if (loadStall || reqStall2 || annulAfterExec) begin
                d2e <= Invalid;
            end else begin
                d2e <= Valid(D2E{pc: f2d_v.pc, dInst: dInst, rVal1: rVal1, rVal2: rVal2});
            end

        end else begin
            //assign d2e
            if (dStall || dStall2 || reqStall) begin
                //do nothing
            end else if (reqStall2) begin
                d2e <= Invalid;
            end else begin
                decodeStall = True;  //if no instruction has been fetched, then fetch should not move on to the next instruction.
                d2e <= Invalid;
            end
        end

        if (isValid(fetch.f2d2)) begin
            let f2d2_v = fromMaybe(?, fetch.f2d2);
            ///////////////
            // Decode #2 //
            ///////////////

            DecodedInst dInst2 = decode(f2d2_v.inst);
            Word rVal12 = rf.rd1(dInst2.src1);
            Word rVal22 = rf.rd2(dInst2.src2);

//$display("DECODED: src12: %d, src22: %d, dst2: %d", dInst2.src1, dInst2.src2, fromMaybe(0, dInst2.dst));
//$display("ITYPE: ", fshow(dInst2.iType));
//$display("inst: %b", f2d2_v.inst);
//printer2.toString = Valid(dInst2);

            if (dstW == dInst2.src1) rVal12 = dataW;
            if (dstW == dInst2.src2) rVal22 = dataW;
            if (dstW2 == dInst2.src1) rVal12 = dataW2;
            if (dstW2 == dInst2.src2) rVal22 = dataW2;
            if (dstE == dInst2.src1) rVal12 = dataE;
            if (dstE == dInst2.src2) rVal22 = dataE;
            if (dstE2 == dInst2.src1) rVal12 = dataE2;
            if (dstE2 == dInst2.src2) rVal22 = dataE2;

            if (loadInto != 0 && (loadInto == dInst2.src1 || loadInto == dInst2.src2)) loadStall2 = True;
            if (loadInto2 != 0 && (loadInto2 == dInst2.src1 || loadInto2 == dInst2.src2)) loadStall2 = True;

            if (dstD != 0 && (dstD == dInst2.src1 || dstD == dInst2.src2)) consecExecStall = True;

            if (dInst2.iType == STORE && branchOrJumpInDecode) consecExecStall = True;

            //if (dInst2.iType == STORE || dInst2.iType == LOAD || dInst2.iType == BRANCH || dInst2.iType == JAL || dInst2.iType == JALR) consecExecStall = True;
            //if (dInst2.iType == BRANCH || dInst2.iType == JAL || dInst2.iType == JALR) consecExecStall = True;
            //consecExecStall = True;

            //assign d2e2
            if (dStall || dStall2 || reqStall || reqStall2) begin
                //do nothing, just wait
            end else if (loadStall || loadStall2 || consecExecStall || annulAfterExec || annulAfterExec2) begin
                d2e2 <= Invalid;
            end else begin
                d2e2 <= Valid(D2E2{pc: f2d2_v.pc, dInst: dInst2, rVal1: rVal12, rVal2: rVal22, src1: dInst2.src1, src2: dInst2.src2});
            end

        end else begin
            //assign d2e2
            if (dStall || dStall2 || reqStall || reqStall2 || loadStall || loadStall2) begin
                //do nothing
            end else begin
                d2e2 <= Invalid;
            end
        end


        ///////////////////////
        // Drive fetch stage //
        ///////////////////////

        if (dStall || dStall2 || reqStall || reqStall2 || loadStall) begin
            fetch.in = FetchInput{fetchAction: Stall, redirectPC: ?};
        end else if (annulAfterExec || annulAfterExec2) begin
            fetch.in = FetchInput{fetchAction: Redirect, redirectPC: redirectPC};
        end else if (reqStall2) begin
            fetch.in = FetchInput{fetchAction: Stall, redirectPC: ?};
        end else if (consecExecStall || loadStall2) begin  //only one instruction made it through, so we increment the pc by 4.
            fetch.in = FetchInput{fetchAction: Shuffle, redirectPC: ?};
        end else if (decodeStall) begin
            fetch.in = FetchInput{fetchAction: Stall, redirectPC: ?};
        end else begin
            fetch.in = FetchInput{fetchAction: Dequeue, redirectPC: ?};
        end

//$display("Stalls: dStall %h dStall2 %h reqStall %h reqStall2 %h loadStall %h loadStall2 %h consecExecStall %h decodeStall %h", dStall, dStall2, reqStall, reqStall2, loadStall, loadStall2, consecExecStall, decodeStall);
//$display("Stalls:", dStall ? " dStall" : "", dStall2 ? " dStall2" : "", reqStall ? " reqStall" : "", reqStall2 ? " reqStall2" : "", loadStall ? " loadStall" : "", loadStall2 ? " loadStall2" : "", consecExecStall ? " consecExecStall" : "", decodeStall ? " decodeStall" : "");
    endrule

    // This method gives a non-trivial output that depends on execution so that
    // synth doesn't optimize out the whole processor :)
    method Word getPc = fetch.getPc;
endmodule


`,
                color: [],
            });

            sources.delete("big file");

            /* Put the sources into the document */
            sourceDivs = new Map(); //each of these maps filenames to DOM elements.
            sourceTitleDivs = new Map();

            /* Given a filename, pulls out the given source. */
            pullGivenSource = (filename) => {
                sourceDivs.forEach((sourceDiv, otherFilename) => {
                    sourceDiv.style.zIndex = 0;
                });
                sourceTitleDivs.forEach((sourceTitle, otherFilename) => {
                    sourceTitle.style.backgroundColor = "var(--button-gray)";
                });
                sourceDivs.get(filename).style.zIndex = 1;
                sourceTitleDivs.get(filename).style.backgroundColor = "white";
            };

            for (let [sourceFileName, source] of sources) {
                let newSource = document.createElement("div");
                newSource.classList.add("source-file-div");
                let sourceLetters = [];
                for (let index = 0; index < source.text.length; index++) {
                    let letter = source.text[index];
                    let color = source.color[index];
                    if (color === undefined) {
                        color = "pink";
                    }
                    let littleLetter = document.createElement("mark");
                    littleLetter.innerHTML = letter;
                    littleLetter.style.color = color;
                    sourceLetters.push(littleLetter);
                }
                for (let mark of sourceLetters) {
                    newSource.appendChild(mark);
                }
                sourceFiletextDisplay.appendChild(newSource);
                sourceDivs.set(sourceFileName, newSource);

                let newSourceTitle = document.createElement("div");
                newSourceTitle.classList.add("source-filename-div");
                newSourceTitle.innerHTML = sourceFileName;
                newSourceTitle.addEventListener("mousedown", (event) => {});
                newSourceTitle.addEventListener("click", (event) => {
                    pullGivenSource(sourceFileName);
                });
                sourceFilenameDisplay.appendChild(newSourceTitle);
                sourceTitleDivs.set(sourceFileName, newSourceTitle);
            }
            pullGivenSource([...sources.keys()][0]); //Pull out the first source file to start

            highlightLocation = (source, index) => {};

            /* An element to place has type
                                        element = { name: string, type: string, variant: "Module" | "Wire",
                                                    uniqueId: string
                                                    source: Array<[number, number]>, typeSource: Array<[number, number]> }
                                        Module = element & {x: number, y: number, width: number, height: number,
                                                            children: Array<element>}
                                        Wire = element & {startx, starty, endx, endy, x1, x2, height (all numbers)}
                                    */
            elementsToPlace = [
                {
                    name: "Box of Latkes",
                    type: "Box#(5)",
                    variant: "Module",
                    uniqueId: "asdf",
                    source: [
                        [5, 10],
                        [30, 40],
                    ],
                    typeSource: [],
                    x: 10,
                    y: 10,
                    width: 80,
                    height: 60,
                    children: [
                        {
                            name: "SubBox Blah Blah Blah",
                            type: "LittleBox#(3)",
                            variant: "Module",
                            uniqueId: "jkl",
                            source: [[60, 100]],
                            typeSource: [],
                            x: 40,
                            y: 40,
                            width: 10,
                            height: 10,
                            children: [],
                        },
                    ],
                },
            ];
            placeElement = (element) => {
                if (element.variant === "Module") {
                    let overRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    let underRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    for (rect of [overRect, underRect]) {
                        rect.setAttribute("x", element.x);
                        rect.setAttribute("y", element.y);
                        rect.setAttribute("width", element.width);
                        rect.setAttribute("height", element.height);
                        rect.setAttribute("stroke", "black");
                        rect.setAttribute("stroke-width", element.height / 50); //make the thickness proportional to the height so that it does not cover the under text
                        rect.setAttribute("fill", "white");
                    }
                    svgDisplay.appendChild(underRect);
                    for (childElement of element.children) {
                        placeElement(childElement);
                    }
                    svgDisplay.appendChild(overRect);
                    //place text
                    let overName = fitText(element.name, {
                        x: element.x,
                        y: element.y,
                        width: element.width,
                        height: element.height / 2,
                    });
                    let overType = fitText(element.type, {
                        x: element.x,
                        y: element.y + element.height / 2,
                        width: element.width,
                        height: element.height / 2,
                    });
                    let underName = fitText(element.name, {
                        x: element.x,
                        y: element.y + element.height,
                        width: element.width / 2,
                        height: element.height / 8,
                    });
                    let underType = fitText(element.type, {
                        x: element.x,
                        y: element.y + element.height + element.height / 8,
                        width: element.width / 2,
                        height: element.height / 8,
                    });
                    underName.style.visibility = "hidden";
                    underType.style.visibility = "hidden";
                    //handle opening the module
                    let open = () => {
                        overRect.style.visibility = "hidden";
                        overName.style.visibility = "hidden";
                        overType.style.visibility = "hidden";
                        underName.style.visibility = "";
                        underType.style.visibility = "";
                    };
                    overRect.addEventListener("dblclick", () => {
                        open();
                    });
                    overName.addEventListener("dblclick", () => {
                        open();
                    });
                    overType.addEventListener("dblclick", () => {
                        open();
                    });
                }
            };
            for (let element of elementsToPlace) {
                placeElement(element);
            }
            highlightValues = (locations) => {
                //locations is a list of pairs of coordinates.
                let current = 0;
                let text = "";
                for (let selection of locations) {
                    start = selection[0];
                    end = selection[1];
                    text += source.slice(current, start) + "<mark>" + source.slice(start, end) + "</mark>";
                    current = end;
                }
                text += source.slice(current);
                sourceDisplay.innerHTML = text;
            };
            /*highlightValues([
                            [1, 2],
                            [3, 4],
                            [5, 6],
                        ]);*/
        </script>
    </body>
</html>
